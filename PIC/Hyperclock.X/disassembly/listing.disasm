Disassembly Listing for ClockClock2
Generated From:
D:/Geeky/ClockClock/ClockClock2.X/dist/default/debug/ClockClock2.X.debug.elf
11-Nov-2019 11:33:06

---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/tmr2.c  --------------------------------------
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F15355
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above 
21:                    MPLAB 	          :  MPLAB X 5.20
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr2.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: TMR2 APIs
60:            */
61:            
62:            void TMR2_Initialize(void)
63:            {
64:                // Set TMR2 to the options selected in the User Interface
65:            
66:                // T2CS FOSC/4; 
67:                T2CLKCON = 0x01;
06FB  3001     MOVLW 0x1
06FC  0145     MOVLB 0x5
06FD  0090     MOVWF T2CLKCON
68:            
69:                // T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Not Synchronized; 
70:                T2HLT = 0x00;
06FE  018F     CLRF T2HLT
71:            
72:                // T2RSEL T2INPPS pin; 
73:                T2RST = 0x00;
06FF  0191     CLRF T2RST
74:            
75:                // T2PR 99; 
76:                T2PR = 0x63;
0700  3063     MOVLW 0x63
0701  008D     MOVWF T2PR
77:            
78:                // TMR2 0; 
79:                T2TMR = 0x00;
0702  018C     CLRF T2TMR
80:            
81:                // Clearing IF flag.
82:                PIR4bits.TMR2IF = 0;
0703  014E     MOVLB 0xE
0704  1090     BCF PIR4, 0x1
83:            
84:                // T2CKPS 1:4; T2OUTPS 1:1; TMR2ON on; 
85:                T2CON = 0xA0;
0705  30A0     MOVLW 0xA0
0706  0145     MOVLB 0x5
0707  008E     MOVWF T2CON
86:            }
0708  0008     RETURN
87:            
88:            void TMR2_ModeSet(TMR2_HLT_MODE mode)
89:            {
90:               // Configure different types HLT mode
91:                T2HLTbits.MODE = mode;
92:            }
93:            
94:            void TMR2_ExtResetSourceSet(TMR2_HLT_EXT_RESET_SOURCE reset)
95:            {
96:                //Configure different types of HLT external reset source
97:                T2RSTbits.RSEL = reset;
98:            }
99:            
100:           void TMR2_Start(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T2CONbits.TMR2ON = 1;
104:           }
105:           
106:           void TMR2_StartTimer(void)
107:           {
108:               TMR2_Start();
109:           }
110:           
111:           void TMR2_Stop(void)
112:           {
113:               // Stop the Timer by writing to TMRxON bit
114:               T2CONbits.TMR2ON = 0;
115:           }
116:           
117:           void TMR2_StopTimer(void)
118:           {
119:               TMR2_Stop();
120:           }
121:           
122:           uint8_t TMR2_Counter8BitGet(void)
123:           {
124:               uint8_t readVal;
125:           
126:               readVal = TMR2;
127:           
128:               return readVal;
129:           }
130:           
131:           uint8_t TMR2_ReadTimer(void)
132:           {
133:               return TMR2_Counter8BitGet();
134:           }
135:           
136:           void TMR2_Counter8BitSet(uint8_t timerVal)
137:           {
138:               // Write to the Timer2 register
139:               TMR2 = timerVal;
140:           }
141:           
142:           void TMR2_WriteTimer(uint8_t timerVal)
143:           {
144:               TMR2_Counter8BitSet(timerVal);
145:           }
146:           
147:           void TMR2_Period8BitSet(uint8_t periodVal)
148:           {
149:              PR2 = periodVal;
150:           }
151:           
152:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
153:           {
154:              TMR2_Period8BitSet(periodVal);
155:           }
156:           
157:           bool TMR2_HasOverflowOccured(void)
158:           {
159:               // check if  overflow has occurred by checking the TMRIF bit
160:               bool status = PIR4bits.TMR2IF;
161:               if(status)
162:               {
163:                   // Clearing IF flag.
164:                   PIR4bits.TMR2IF = 0;
165:               }
166:               return status;
167:           }
168:           /**
169:             End of File
170:           */
---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/tmr0.c  --------------------------------------
1:             /**
2:               TMR0 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr0.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR0 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR0.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F15355
18:                    Driver Version    :  3.10
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above
21:                    MPLAB 	          :  MPLAB X 5.20
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr0.h"
53:            
54:            
55:            /**
56:              Section: TMR0 APIs
57:            */
58:            
59:            void (*TMR0_InterruptHandler)(void);
60:            
61:            void TMR0_Initialize(void)
62:            {
63:                // Set TMR0 to the options selected in the User Interface
64:            
65:                // T0CS FOSC/4; T0CKPS 1:64; T0ASYNC not_synchronised; 
66:                T0CON1 = 0x56;
06D8  3056     MOVLW 0x56
06D9  014B     MOVLB 0xB
06DA  009F     MOVWF T0CON1
67:            
68:                // TMR0H 124; 
69:                TMR0H = 0x7C;
06DB  307C     MOVLW 0x7C
06DC  009D     MOVWF TMR0H
70:            
71:                // TMR0L 0; 
72:                TMR0L = 0x00;
06DD  019C     CLRF TMR0L
73:            
74:                // Clear Interrupt flag before enabling the interrupt
75:                PIR0bits.TMR0IF = 0;
06DE  014E     MOVLB 0xE
06DF  128C     BCF PIR0, 0x5
76:            
77:                // Enabling TMR0 interrupt.
78:                PIE0bits.TMR0IE = 1;
06E0  1696     BSF PIE0, 0x5
79:            
80:                // Set Default Interrupt Handler
81:                TMR0_SetInterruptHandler(TMR0_DefaultInterruptHandler);
06E1  3087     MOVLW 0x87
06E2  0140     MOVLB 0x0
06E3  00D4     MOVWF InterruptHandler
06E4  3007     MOVLW 0x7
06E5  00D5     MOVWF readValue
06E6  3187     MOVLP 0x7
06E7  273F     CALL 0x73F
82:            
83:                // T0OUTPS 1:1; T0EN enabled; T016BIT 8-bit; 
84:                T0CON0 = 0x80;
06E8  3080     MOVLW 0x80
06E9  014B     MOVLB 0xB
06EA  009E     MOVWF T0CON0
85:            }
06EB  0008     RETURN
86:            
87:            void TMR0_StartTimer(void)
88:            {
89:                // Start the Timer by writing to TMR0ON bit
90:                T0CON0bits.T0EN = 1;
91:            }
92:            
93:            void TMR0_StopTimer(void)
94:            {
95:                // Stop the Timer by writing to TMR0ON bit
96:                T0CON0bits.T0EN = 0;
97:            }
98:            
99:            uint8_t TMR0_ReadTimer(void)
100:           {
101:               uint8_t readVal;
102:           
103:               // read Timer0, low register only
104:               readVal = TMR0L;
105:           
106:               return readVal;
107:           }
108:           
109:           void TMR0_WriteTimer(uint8_t timerVal)
110:           {
111:               // Write to Timer0 registers, low register only
112:               TMR0L = timerVal;
113:            }
114:           
115:           void TMR0_Reload(uint8_t periodVal)
116:           {
117:              // Write to Timer0 registers, high register only
118:              TMR0H = periodVal;
119:           }
120:           
121:           void TMR0_ISR(void)
122:           {
123:               // clear the TMR0 interrupt flag
124:               PIR0bits.TMR0IF = 0;
0709  014E     MOVLB 0xE
070A  128C     BCF PIR0, 0x5
125:               if(TMR0_InterruptHandler)
070B  0140     MOVLB 0x0
070C  083A     MOVF TMR0_InterruptHandler, W
070D  043B     IORWF 0x3B, W
070E  1903     BTFSC STATUS, 0x2
070F  0008     RETURN
126:               {
127:                   TMR0_InterruptHandler();
0710  083B     MOVF 0x3B, W
0711  008A     MOVWF PCLATH
0712  083A     MOVF TMR0_InterruptHandler, W
0713  000A     CALLW
0714  3187     MOVLP 0x7
128:               }
129:           
130:               // add your TMR0 interrupt custom code
131:           }
0715  0008     RETURN
132:           
133:           
134:           void TMR0_SetInterruptHandler(void (* InterruptHandler)(void)){
135:               TMR0_InterruptHandler = InterruptHandler;
073F  0140     MOVLB 0x0
0740  0855     MOVF readValue, W
0741  00BB     MOVWF 0x3B
0742  0854     MOVF InterruptHandler, W
0743  00BA     MOVWF TMR0_InterruptHandler
136:           }
0744  0008     RETURN
137:           
138:           void TMR0_DefaultInterruptHandler(void){
139:               // add your TMR0 interrupt custom code
140:               // or set custom function using TMR0_SetInterruptHandler()
141:           }
0787  0008     RETURN
142:           
143:           /**
144:             End of File
145:           */
---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/pwm6.c  --------------------------------------
1:              /**
2:                PWM6 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  pwm6.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the PWM6 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for PWM6.
15:                 Generation Information :
16:                     Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                     Device            :  PIC16F15355
18:                     Driver Version    :  2.01
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 2.05 and above or later
21:                     MPLAB             :  MPLAB X 5.20
22:             */ 
23:            
24:             /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:             /**
48:               Section: Included Files
49:             */
50:            
51:             #include <xc.h>
52:             #include "pwm6.h"
53:            
54:             /**
55:               Section: PWM Module APIs
56:             */
57:            
58:             void PWM6_Initialize(void)
59:             {
60:                // Set the PWM to the options selected in the PIC10 / PIC12 / PIC16 / PIC18 MCUs.
61:                // PWM6POL active_hi; PWM6EN enabled; 
62:                PWM6CON = 0x80;   
0745  3080     MOVLW 0x80
0746  0147     MOVLB 0x7
0747  008E     MOVWF PWM6CON
63:            
64:                // DC 0; 
65:                PWM6DCH = 0x00;   
0748  018D     CLRF PWM6DCH
66:            
67:                // DC 0; 
68:                PWM6DCL = 0x00;   
0749  018C     CLRF PWM6DC
69:            
70:             }
074A  0008     RETURN
71:            
72:             void PWM6_LoadDutyValue(uint16_t dutyValue)
73:             {
74:                 // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
75:                 PWM6DCH = (dutyValue & 0x03FC)>>2;
0680  0871     MOVF 0x3F1, W
0681  00F3     MOVWF 0x3F3
0682  0870     MOVF 0x3F0, W
0683  00F2     MOVWF 0x3F2
0684  36F3     LSRF 0x3F3, F
0685  0CF2     RRF 0x3F2, F
0686  36F3     LSRF 0x3F3, F
0687  0CF2     RRF 0x3F2, F
0688  0872     MOVF 0x3F2, W
0689  0147     MOVLB 0x7
068A  008D     MOVWF PWM6DCH
76:                 
77:                 // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
78:                 PWM6DCL = (dutyValue & 0x0003)<<6;
068B  0870     MOVF 0x3F0, W
068C  3903     ANDLW 0x3
068D  00F2     MOVWF 0x3F2
068E  3005     MOVLW 0x5
068F  35F2     LSLF 0x3F2, F
0690  3EFF     ADDLW 0xFF
0691  1D03     BTFSS 0x383, 0x2
0692  2E8F     GOTO 0x68F
0693  3572     LSLF 0x3F2, W
0694  008C     MOVWF PWM6DC
79:             }
0695  0008     RETURN
80:             /**
81:              End of File
82:             */
---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/pwm5.c  --------------------------------------
1:              /**
2:                PWM5 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  pwm5.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the PWM5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for PWM5.
15:                 Generation Information :
16:                     Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                     Device            :  PIC16F15355
18:                     Driver Version    :  2.01
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 2.05 and above or later
21:                     MPLAB             :  MPLAB X 5.20
22:             */ 
23:            
24:             /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:             /**
48:               Section: Included Files
49:             */
50:            
51:             #include <xc.h>
52:             #include "pwm5.h"
53:            
54:             /**
55:               Section: PWM Module APIs
56:             */
57:            
58:             void PWM5_Initialize(void)
59:             {
60:                // Set the PWM to the options selected in the PIC10 / PIC12 / PIC16 / PIC18 MCUs.
61:                // PWM5POL active_hi; PWM5EN enabled; 
62:                PWM5CON = 0x80;   
074B  3080     MOVLW 0x80
074C  0146     MOVLB 0x6
074D  009E     MOVWF PWM5CON
63:            
64:                // DC 0; 
65:                PWM5DCH = 0x00;   
074E  019D     CLRF PWM5DCH
66:            
67:                // DC 0; 
68:                PWM5DCL = 0x00;   
074F  019C     CLRF PWM5DC
69:            
70:             }
0750  0008     RETURN
71:            
72:             void PWM5_LoadDutyValue(uint16_t dutyValue)
73:             {
74:                 // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
75:                 PWM5DCH = (dutyValue & 0x03FC)>>2;
0696  0871     MOVF 0x371, W
0697  00F3     MOVWF 0x373
0698  0870     MOVF 0x370, W
0699  00F2     MOVWF 0x372
069A  36F3     LSRF 0x373, F
069B  0CF2     RRF 0x372, F
069C  36F3     LSRF 0x373, F
069D  0CF2     RRF 0x372, F
069E  0872     MOVF 0x372, W
069F  0146     MOVLB 0x6
06A0  009D     MOVWF PWM5DCH
76:                 
77:                 // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
78:                 PWM5DCL = (dutyValue & 0x0003)<<6;
06A1  0870     MOVF 0x370, W
06A2  3903     ANDLW 0x3
06A3  00F2     MOVWF 0x372
06A4  3005     MOVLW 0x5
06A5  35F2     LSLF 0x372, F
06A6  3EFF     ADDLW 0xFF
06A7  1D03     BTFSS 0x303, 0x2
06A8  2EA5     GOTO 0x6A5
06A9  3572     LSLF 0x372, W
06AA  009C     MOVWF PWM5DC
79:             }
06AB  0008     RETURN
80:             /**
81:              End of File
82:             */
---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/pwm4.c  --------------------------------------
1:              /**
2:                PWM4 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  pwm4.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the PWM4 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for PWM4.
15:                 Generation Information :
16:                     Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                     Device            :  PIC16F15355
18:                     Driver Version    :  2.01
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 2.05 and above or later
21:                     MPLAB             :  MPLAB X 5.20
22:             */ 
23:            
24:             /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:             /**
48:               Section: Included Files
49:             */
50:            
51:             #include <xc.h>
52:             #include "pwm4.h"
53:            
54:             /**
55:               Section: PWM Module APIs
56:             */
57:            
58:             void PWM4_Initialize(void)
59:             {
60:                // Set the PWM to the options selected in the PIC10 / PIC12 / PIC16 / PIC18 MCUs.
61:                // PWM4POL active_hi; PWM4EN enabled; 
62:                PWM4CON = 0x80;   
0751  3080     MOVLW 0x80
0752  0146     MOVLB 0x6
0753  009A     MOVWF PWM4CON
63:            
64:                // DC 0; 
65:                PWM4DCH = 0x00;   
0754  0199     CLRF PWM4DCH
66:            
67:                // DC 0; 
68:                PWM4DCL = 0x00;   
0755  0198     CLRF PWM4DC
69:            
70:             }
0756  0008     RETURN
71:            
72:             void PWM4_LoadDutyValue(uint16_t dutyValue)
73:             {
74:                 // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
75:                 PWM4DCH = (dutyValue & 0x03FC)>>2;
06AC  0871     MOVF 0x371, W
06AD  00F3     MOVWF 0x373
06AE  0870     MOVF 0x370, W
06AF  00F2     MOVWF 0x372
06B0  36F3     LSRF 0x373, F
06B1  0CF2     RRF 0x372, F
06B2  36F3     LSRF 0x373, F
06B3  0CF2     RRF 0x372, F
06B4  0872     MOVF 0x372, W
06B5  0146     MOVLB 0x6
06B6  0099     MOVWF PWM4DCH
76:                 
77:                 // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
78:                 PWM4DCL = (dutyValue & 0x0003)<<6;
06B7  0870     MOVF 0x370, W
06B8  3903     ANDLW 0x3
06B9  00F2     MOVWF 0x372
06BA  3005     MOVLW 0x5
06BB  35F2     LSLF 0x372, F
06BC  3EFF     ADDLW 0xFF
06BD  1D03     BTFSS 0x303, 0x2
06BE  2EBB     GOTO 0x6BB
06BF  3572     LSLF 0x372, W
06C0  0098     MOVWF PWM4DC
79:             }
06C1  0008     RETURN
80:             /**
81:              End of File
82:             */
---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/pwm3.c  --------------------------------------
1:              /**
2:                PWM3 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  pwm3.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the PWM3 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for PWM3.
15:                 Generation Information :
16:                     Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                     Device            :  PIC16F15355
18:                     Driver Version    :  2.01
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 2.05 and above or later
21:                     MPLAB             :  MPLAB X 5.20
22:             */ 
23:            
24:             /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:             /**
48:               Section: Included Files
49:             */
50:            
51:             #include <xc.h>
52:             #include "pwm3.h"
53:            
54:             /**
55:               Section: PWM Module APIs
56:             */
57:            
58:             void PWM3_Initialize(void)
59:             {
60:                // Set the PWM to the options selected in the PIC10 / PIC12 / PIC16 / PIC18 MCUs.
61:                // PWM3POL active_hi; PWM3EN enabled; 
62:                PWM3CON = 0x80;   
0757  3080     MOVLW 0x80
0758  0146     MOVLB 0x6
0759  0096     MOVWF PWM3CON
63:            
64:                // DC 0; 
65:                PWM3DCH = 0x00;   
075A  0195     CLRF PWM3DCH
66:            
67:                // DC 0; 
68:                PWM3DCL = 0x00;   
075B  0194     CLRF PWM3DC
69:            
70:             }
075C  0008     RETURN
71:            
72:             void PWM3_LoadDutyValue(uint16_t dutyValue)
73:             {
74:                 // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
75:                 PWM3DCH = (dutyValue & 0x03FC)>>2;
06C2  0871     MOVF 0x371, W
06C3  00F3     MOVWF 0x373
06C4  0870     MOVF 0x370, W
06C5  00F2     MOVWF 0x372
06C6  36F3     LSRF 0x373, F
06C7  0CF2     RRF 0x372, F
06C8  36F3     LSRF 0x373, F
06C9  0CF2     RRF 0x372, F
06CA  0872     MOVF 0x372, W
06CB  0146     MOVLB 0x6
06CC  0095     MOVWF PWM3DCH
76:                 
77:                 // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
78:                 PWM3DCL = (dutyValue & 0x0003)<<6;
06CD  0870     MOVF 0x370, W
06CE  3903     ANDLW 0x3
06CF  00F2     MOVWF 0x372
06D0  3005     MOVLW 0x5
06D1  35F2     LSLF 0x372, F
06D2  3EFF     ADDLW 0xFF
06D3  1D03     BTFSS 0x303, 0x2
06D4  2ED1     GOTO 0x6D1
06D5  3572     LSLF 0x372, W
06D6  0094     MOVWF PWM3DC
79:             }
06D7  0008     RETURN
80:             /**
81:              End of File
82:             */
---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/pin_manager.c  -------------------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F15355
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above
21:                    MPLAB             :  MPLAB X 5.20
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "pin_manager.h"
50:            
51:            
52:            
53:            
54:            
55:            void PIN_MANAGER_Initialize(void)
56:            {
57:                /**
58:                LATx registers
59:                */
60:                LATA = 0x00;
0546  0140     MOVLB 0x0
0547  0198     CLRF LATA
61:                LATB = 0x00;
0548  0199     CLRF LATB
62:                LATC = 0x00;
0549  019A     CLRF LATC
63:            
64:                /**
65:                TRISx registers
66:                */
67:                TRISA = 0xDF;
054A  30DF     MOVLW 0xDF
054B  0092     MOVWF TRISA
68:                TRISB = 0x00;
054C  0193     CLRF TRISB
69:                TRISC = 0x0A;
054D  300A     MOVLW 0xA
054E  0094     MOVWF TRISC
70:            
71:                /**
72:                ANSELx registers
73:                */
74:                ANSELC = 0x00;
054F  017E     MOVLB 0x3E
0550  01CE     CLRF ANSELC
75:                ANSELB = 0x00;
0551  01C3     CLRF ANSELB
76:                ANSELA = 0xC0;
0552  30C0     MOVLW 0xC0
0553  00B8     MOVWF ANSELA
77:            
78:                /**
79:                WPUx registers
80:                */
81:                WPUE = 0x00;
0554  01E5     CLRF WPUE
82:                WPUB = 0x00;
0555  01C4     CLRF WPUB
83:                WPUA = 0x00;
0556  01B9     CLRF WPUA
84:                WPUC = 0x02;
0557  3002     MOVLW 0x2
0558  00CF     MOVWF WPUC
85:            
86:                /**
87:                ODx registers
88:                */
89:                ODCONA = 0x00;
0559  01BA     CLRF ODCONA
90:                ODCONB = 0x00;
055A  01C5     CLRF ODCONB
91:                ODCONC = 0x00;
055B  01D0     CLRF ODCONC
92:            
93:                /**
94:                SLRCONx registers
95:                */
96:                SLRCONA = 0xFF;
055C  30FF     MOVLW 0xFF
055D  00BB     MOVWF SLRCONA
97:                SLRCONB = 0xFF;
055E  30FF     MOVLW 0xFF
055F  00C6     MOVWF SLRCONB
98:                SLRCONC = 0xFF;
0560  30FF     MOVLW 0xFF
0561  00D1     MOVWF SLRCONC
99:            
100:               /**
101:               INLVLx registers
102:               */
103:               INLVLA = 0xFF;
0562  30FF     MOVLW 0xFF
0563  00BC     MOVWF INLVLA
104:               INLVLB = 0xFF;
0564  30FF     MOVLW 0xFF
0565  00C7     MOVWF INLVLB
105:               INLVLC = 0xFF;
0566  30FF     MOVLW 0xFF
0567  00D2     MOVWF INLVLC
106:               INLVLE = 0x08;
0568  3008     MOVLW 0x8
0569  00E8     MOVWF INLVLE
107:           
108:           
109:           
110:           
111:           
112:              
113:               
114:               #if (__XC8_VERSION <= 1380)
115:               #define ADACTPPSbits ADCACTPPSbits
116:               #endif
117:           	
118:               CLCIN0PPS = 0x13;   //RC3->CLC1:CLCIN0;    
056A  3013     MOVLW 0x13
056B  017D     MOVLB 0x3D
056C  00BB     MOVWF CLCIN0PPS
119:               RB5PPS = 0x0B;   //RB5->PWM3:PWM3OUT;    
056D  300B     MOVLW 0xB
056E  017E     MOVLB 0x3E
056F  009D     MOVWF RB5PPS
120:               RB3PPS = 0x0C;   //RB3->PWM4:PWM4OUT;    
0570  300C     MOVLW 0xC
0571  009B     MOVWF RB3PPS
121:               RC2PPS = 0x01;   //RC2->CLC1:CLC1OUT;    
0572  3001     MOVLW 0x1
0573  00A2     MOVWF RC2PPS
122:               RC5PPS = 0x0E;   //RC5->PWM6:PWM6OUT;    
0574  300E     MOVLW 0xE
0575  00A5     MOVWF RC5PPS
123:               RC7PPS = 0x0D;   //RC7->PWM5:PWM5OUT;    
0576  300D     MOVLW 0xD
0577  00A7     MOVWF RC7PPS
124:               RX1DTPPS = 0x11;   //RC1->EUSART1:RX1;    
0578  3011     MOVLW 0x11
0579  017D     MOVLB 0x3D
057A  00CB     MOVWF RX1DTPPS
125:           }
057B  0008     RETURN
126:             
127:           void PIN_MANAGER_IOC(void)
128:           {   
129:           }
130:           
131:           /**
132:            End of File
133:           */
---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/mcc.c  ---------------------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F15355
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above or later
21:                    MPLAB             :  MPLAB X 5.20
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                PMD_Initialize();
05D3  3187     MOVLP 0x7
05D4  272A     CALL 0x72A
05D5  3185     MOVLP 0x5
53:                PIN_MANAGER_Initialize();
05D6  3185     MOVLP 0x5
05D7  2546     CALL 0x546
05D8  3185     MOVLP 0x5
54:                OSCILLATOR_Initialize();
05D9  3187     MOVLP 0x7
05DA  2716     CALL 0x716
05DB  3185     MOVLP 0x5
55:                PWM6_Initialize();
05DC  3187     MOVLP 0x7
05DD  2745     CALL 0x745
05DE  3185     MOVLP 0x5
56:                CLC1_Initialize();
05DF  3186     MOVLP 0x6
05E0  26EC     CALL 0x6EC
05E1  3185     MOVLP 0x5
57:                PWM4_Initialize();
05E2  3187     MOVLP 0x7
05E3  2751     CALL 0x751
05E4  3185     MOVLP 0x5
58:                PWM3_Initialize();
05E5  3187     MOVLP 0x7
05E6  2757     CALL 0x757
05E7  3185     MOVLP 0x5
59:                TMR2_Initialize();
05E8  3186     MOVLP 0x6
05E9  26FB     CALL 0x6FB
05EA  3185     MOVLP 0x5
60:                PWM5_Initialize();
05EB  3187     MOVLP 0x7
05EC  274B     CALL 0x74B
05ED  3185     MOVLP 0x5
61:                TMR0_Initialize();
05EE  3186     MOVLP 0x6
05EF  26D8     CALL 0x6D8
05F0  3185     MOVLP 0x5
62:                EUSART1_Initialize();
05F1  3184     MOVLP 0x4
05F2  2414     CALL 0x414
63:            }
05F3  0008     RETURN
64:            
65:            void OSCILLATOR_Initialize(void)
66:            {
67:                // NOSC EXTOSC   with 4x PLL; NDIV 1; 
68:                OSCCON1 = 0x20;
0716  3020     MOVLW 0x20
0717  0151     MOVLB 0x11
0718  008D     MOVWF OSCCON1
69:                // CSWHOLD may proceed; SOSCPWR Low power; 
70:                OSCCON3 = 0x00;
0719  018F     CLRF OSCCON3
71:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
72:                OSCEN = 0x00;
071A  0191     CLRF OSCEN
73:                // HFFRQ 4_MHz; 
74:                OSCFRQ = 0x02;
071B  3002     MOVLW 0x2
071C  0093     MOVWF OSCFRQ
75:                // MFOR not ready; 
76:                OSCSTAT = 0x00;
071D  0190     CLRF OSCSTAT
77:                // HFTUN 0; 
78:                OSCTUNE = 0x00;
071E  0192     CLRF OSCTUNE
79:                // Wait for PLL to stabilize
80:                while(PLLR == 0)
81:                {
82:                }
071F  1810     BTFSC OSCSTAT, 0x0
0720  0008     RETURN
0721  2F1F     GOTO 0x71F
83:            }
84:            
85:            void PMD_Initialize(void)
86:            {
87:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; FVRMD FVR enabled; IOCMD IOC enabled; NVMMD NVM enabled; 
88:                PMD0 = 0x00;
072A  014F     MOVLB 0xF
072B  0196     CLRF PMD0
89:                // TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR2MD TMR2 enabled; NCOMD DDS(NCO) enabled; 
90:                PMD1 = 0x00;
072C  0197     CLRF PMD1
91:                // ZCDMD ZCD enabled; CMP1MD CMP1 enabled; ADCMD ADC enabled; CMP2MD CMP2 enabled; DAC1MD DAC1 enabled; 
92:                PMD2 = 0x00;
072D  0198     CLRF PMD2
93:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; PWM4MD PWM4 enabled; PWM3MD PWM3 enabled; PWM6MD PWM6 enabled; PWM5MD PWM5 enabled; 
94:                PMD3 = 0x00;
072E  0199     CLRF PMD3
95:                // CWG1MD CWG1 enabled; UART2MD EUSART2 enabled; MSSP1MD MSSP1 enabled; UART1MD EUSART enabled; MSSP2MD MSSP2 enabled; 
96:                PMD4 = 0x00;
072F  019A     CLRF PMD4
97:                // CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
98:                PMD5 = 0x00;
0730  019B     CLRF PMD5
99:            }
0731  0008     RETURN
100:           
101:           
102:           /**
103:            End of File
104:           */
---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/interrupt_manager.c  -------------------------
1:             /**
2:               Generated Interrupt Manager Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.c
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
19:                    Device            :  PIC16F15355
20:                    Driver Version    :  2.03
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 2.05 and above or later
23:                    MPLAB 	          :  MPLAB X 5.20
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void __interrupt() INTERRUPT_InterruptManager (void)
0004  147E     BSF 0x7FE, 0x0
0005  3180     MOVLP 0x0
53:            {
54:                // interrupt handler
55:                if(PIE0bits.TMR0IE == 1 && PIR0bits.TMR0IF == 1)
0006  014E     MOVLB 0xE
0007  1A96     BTFSC PIE0, 0x5
0008  1E8C     BTFSS PIR0, 0x5
0009  280E     GOTO 0xE
56:                {
57:                    TMR0_ISR();
000A  3187     MOVLP 0x7
000B  2709     CALL 0x709
000C  3180     MOVLP 0x0
58:                }
000D  2823     GOTO 0x23
59:                else if(INTCONbits.PEIE == 1)
000E  1F0B     BTFSS 0x70B, 0x6
000F  2823     GOTO 0x23
60:                {
61:                    if(PIE3bits.TX1IE == 1 && PIR3bits.TX1IF == 1)
0010  1A19     BTFSC PIE3, 0x4
0011  1E0F     BTFSS PIR3, 0x4
0012  281A     GOTO 0x1A
62:                    {
63:                        EUSART1_TxDefaultInterruptHandler();
0013  0140     MOVLB 0x0
0014  0839     MOVF 0x39, W
0015  008A     MOVWF PCLATH
0016  0838     MOVF EUSART1_TxDefaultInterruptHandler, W
0017  000A     CALLW
0018  3180     MOVLP 0x0
64:            } 
0019  2823     GOTO 0x23
65:                    else if(PIE3bits.RC1IE == 1 && PIR3bits.RC1IF == 1)
001A  1A99     BTFSC LATB, 0x5
001B  1E8F     BTFSS 0xF, 0x5
001C  2823     GOTO 0x23
66:                    {
67:                        EUSART1_RxDefaultInterruptHandler();
001D  0140     MOVLB 0x0
001E  0837     MOVF 0x37, W
001F  008A     MOVWF PCLATH
0020  0836     MOVF EUSART1_RxDefaultInterruptHandler, W
0021  000A     CALLW
0022  3180     MOVLP 0x0
68:                    } 
69:                }      
70:            }
0023  107E     BCF 0x7E, 0x0
0024  0009     RETFIE
71:            /**
72:             End of File
73:            */
---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/eusart1.c  -----------------------------------
1:             /**
2:               EUSART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 eusart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the EUSART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for EUSART1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F15355
18:                    Driver Version    :  2.1.0
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above
21:                    MPLAB 	          :  MPLAB X 5.20
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include "eusart1.h"
51:            
52:            /**
53:              Section: Macro Declarations
54:            */
55:            
56:            #define EUSART1_TX_BUFFER_SIZE 8
57:            #define EUSART1_RX_BUFFER_SIZE 8
58:            
59:            /**
60:              Section: Global Variables
61:            */
62:            volatile uint8_t eusart1TxHead = 0;
63:            volatile uint8_t eusart1TxTail = 0;
64:            volatile uint8_t eusart1TxBuffer[EUSART1_TX_BUFFER_SIZE];
65:            volatile uint8_t eusart1TxBufferRemaining;
66:            
67:            volatile uint8_t eusart1RxHead = 0;
68:            volatile uint8_t eusart1RxTail = 0;
69:            volatile uint8_t eusart1RxBuffer[EUSART1_RX_BUFFER_SIZE];
70:            volatile eusart1_status_t eusart1RxStatusBuffer[EUSART1_RX_BUFFER_SIZE];
71:            volatile uint8_t eusart1RxCount;
72:            volatile eusart1_status_t eusart1RxLastError;
73:            
74:            /**
75:              Section: EUSART1 APIs
76:            */
77:            void (*EUSART1_TxDefaultInterruptHandler)(void);
78:            void (*EUSART1_RxDefaultInterruptHandler)(void);
79:            
80:            void (*EUSART1_FramingErrorHandler)(void);
81:            void (*EUSART1_OverrunErrorHandler)(void);
82:            void (*EUSART1_ErrorHandler)(void);
83:            
84:            void EUSART1_DefaultFramingErrorHandler(void);
85:            void EUSART1_DefaultOverrunErrorHandler(void);
86:            void EUSART1_DefaultErrorHandler(void);
87:            
88:            void EUSART1_Initialize(void)
89:            {
90:                // disable interrupts before changing states
91:                PIE3bits.RC1IE = 0;
0414  014E     MOVLB 0xE
0415  1299     BCF PIE3, 0x5
92:                EUSART1_SetRxInterruptHandler(EUSART1_Receive_ISR);
0416  307C     MOVLW 0x7C
0417  0140     MOVLB 0x0
0418  00D4     MOVWF InterruptHandler
0419  3005     MOVLW 0x5
041A  00D5     MOVWF readValue
041B  3187     MOVLP 0x7
041C  2763     CALL 0x763
041D  3184     MOVLP 0x4
93:                PIE3bits.TX1IE = 0;
041E  014E     MOVLB 0xE
041F  1219     BCF PIE3, 0x4
94:                EUSART1_SetTxInterruptHandler(EUSART1_Transmit_ISR);
0420  3030     MOVLW 0x30
0421  0140     MOVLB 0x0
0422  00D4     MOVWF InterruptHandler
0423  3006     MOVLW 0x6
0424  00D5     MOVWF readValue
0425  3187     MOVLP 0x7
0426  275D     CALL 0x75D
0427  3184     MOVLP 0x4
95:                // Set the EUSART1 module to the options selected in the user interface.
96:            
97:                // ABDOVF no_overflow; SCKP Non-Inverted; BRG16 16bit_generator; WUE disabled; ABDEN disabled; 
98:                BAUD1CON = 0x08;
0428  3008     MOVLW 0x8
0429  0142     MOVLB 0x2
042A  009F     MOVWF BAUD1CON
99:            
100:               // SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
101:               RC1STA = 0x90;
042B  3090     MOVLW 0x90
042C  009D     MOVWF RC1STA
102:           
103:               // TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN disabled; SYNC asynchronous; BRGH hi_speed; CSRC slave; 
104:               TX1STA = 0x04;
042D  3004     MOVLW 0x4
042E  009E     MOVWF TX1STA
105:           
106:               // SP1BRGL 64; 
107:               SP1BRGL = 0x40;
042F  3040     MOVLW 0x40
0430  009B     MOVWF SP1BRG
108:           
109:               // SP1BRGH 3; 
110:               SP1BRGH = 0x03;
0431  3003     MOVLW 0x3
0432  009C     MOVWF SP1BRGH
111:           
112:           
113:               EUSART1_SetFramingErrorHandler(EUSART1_DefaultFramingErrorHandler);
0433  3088     MOVLW 0x88
0434  0140     MOVLB 0x0
0435  00D4     MOVWF InterruptHandler
0436  3007     MOVLW 0x7
0437  00D5     MOVWF readValue
0438  3187     MOVLP 0x7
0439  276F     CALL 0x76F
043A  3184     MOVLP 0x4
114:               EUSART1_SetOverrunErrorHandler(EUSART1_DefaultOverrunErrorHandler);
043B  307B     MOVLW 0x7B
043C  0140     MOVLB 0x0
043D  00D4     MOVWF InterruptHandler
043E  3007     MOVLW 0x7
043F  00D5     MOVWF readValue
0440  3187     MOVLP 0x7
0441  2769     CALL 0x769
0442  3184     MOVLP 0x4
115:               EUSART1_SetErrorHandler(EUSART1_DefaultErrorHandler);
0443  3082     MOVLW 0x82
0444  0140     MOVLB 0x0
0445  00D4     MOVWF InterruptHandler
0446  3007     MOVLW 0x7
0447  00D5     MOVWF readValue
0448  3187     MOVLP 0x7
0449  2775     CALL 0x775
116:           
117:               eusart1RxLastError.status = 0;
044A  0140     MOVLB 0x0
044B  01C3     CLRF eusart1RxLastError
118:           
119:               // initializing the driver state
120:               eusart1TxHead = 0;
044C  01C7     CLRF eusart1TxHead
121:               eusart1TxTail = 0;
044D  01C6     CLRF eusart1TxTail
122:               eusart1TxBufferRemaining = sizeof(eusart1TxBuffer);
044E  3008     MOVLW 0x8
044F  00D6     MOVWF multiplicand
0450  0856     MOVF multiplicand, W
0451  00C5     MOVWF eusart1TxBufferRemaining
123:           
124:               eusart1RxHead = 0;
0452  01C4     CLRF eusart1RxHead
125:               eusart1RxTail = 0;
0453  01F7     CLRF eusart1RxTail
126:               eusart1RxCount = 0;
0454  01F6     CLRF eusart1RxCount
127:           
128:               // enable receive interrupt
129:               PIE3bits.RC1IE = 1;
0455  014E     MOVLB 0xE
0456  1699     BSF PIE3, 0x5
130:           }
0457  0008     RETURN
131:           
132:           bool EUSART1_is_tx_ready(void)
133:           {
134:               return (eusart1TxBufferRemaining ? true : false);
135:           }
136:           
137:           bool EUSART1_is_rx_ready(void)
138:           {
139:               return (eusart1RxCount ? true : false);
0732  0876     MOVF 0x776, W
0733  1903     BTFSC 0x703, 0x2
0734  2F37     GOTO 0x737
0735  3001     MOVLW 0x1
0736  0008     RETURN
0737  3000     MOVLW 0x0
140:           }
0738  0008     RETURN
141:           
142:           bool EUSART1_is_tx_done(void)
143:           {
144:               return TX1STAbits.TRMT;
145:           }
146:           
147:           eusart1_status_t EUSART1_get_last_status(void){
148:               return eusart1RxLastError;
077F  0140     MOVLB 0x0
0780  0843     MOVF eusart1RxLastError, W
149:           }
0781  0008     RETURN
150:           
151:           uint8_t EUSART1_Read(void)
152:           {
153:               uint8_t readValue  = 0;
154:               
155:               while(0 == eusart1RxCount)
05AF  0876     MOVF eusart1RxCount, W
05B0  1903     BTFSC STATUS, 0x2
05B1  2DAF     GOTO 0x5AF
156:               {
157:               }
158:           
159:               eusart1RxLastError = eusart1RxStatusBuffer[eusart1RxTail];
05B2  0877     MOVF eusart1RxTail, W
05B3  3E20     ADDLW 0x20
05B4  0086     MOVWF FSR1
05B5  0187     CLRF FSR1H
05B6  0801     MOVF INDF1, W
05B7  0140     MOVLB 0x0
05B8  00D4     MOVWF InterruptHandler
05B9  0854     MOVF InterruptHandler, W
05BA  00C3     MOVWF eusart1RxLastError
160:           
161:               readValue = eusart1RxBuffer[eusart1RxTail++];
05BB  0877     MOVF eusart1RxTail, W
05BC  3EA0     ADDLW 0xA0
05BD  0086     MOVWF FSR1
05BE  0187     CLRF FSR1H
05BF  0801     MOVF INDF1, W
05C0  00D4     MOVWF InterruptHandler
05C1  0854     MOVF InterruptHandler, W
05C2  00D5     MOVWF readValue
05C3  3001     MOVLW 0x1
05C4  00D4     MOVWF InterruptHandler
05C5  0854     MOVF InterruptHandler, W
05C6  07F7     ADDWF eusart1RxTail, F
162:               if(sizeof(eusart1RxBuffer) <= eusart1RxTail)
05C7  3008     MOVLW 0x8
05C8  0277     SUBWF eusart1RxTail, W
05C9  1803     BTFSC STATUS, 0x0
163:               {
164:                   eusart1RxTail = 0;
05CA  01F7     CLRF eusart1RxTail
165:               }
166:               PIE3bits.RC1IE = 0;
05CB  014E     MOVLB 0xE
05CC  1299     BCF PIE3, 0x5
167:               eusart1RxCount--;
05CD  3001     MOVLW 0x1
05CE  02F6     SUBWF 0x776, F
168:               PIE3bits.RC1IE = 1;
05CF  1699     BSF PIE3, 0x5
169:           
170:               return readValue;
05D0  0140     MOVLB 0x0
05D1  0855     MOVF readValue, W
171:           }
05D2  0008     RETURN
172:           
173:           void EUSART1_Write(uint8_t txData)
174:           {
175:               while(0 == eusart1TxBufferRemaining)
176:               {
177:               }
178:           
179:               if(0 == PIE3bits.TX1IE)
180:               {
181:                   TX1REG = txData;
182:               }
183:               else
184:               {
185:                   PIE3bits.TX1IE = 0;
186:                   eusart1TxBuffer[eusart1TxHead++] = txData;
187:                   if(sizeof(eusart1TxBuffer) <= eusart1TxHead)
188:                   {
189:                       eusart1TxHead = 0;
190:                   }
191:                   eusart1TxBufferRemaining--;
192:               }
193:               PIE3bits.TX1IE = 1;
194:           }
195:           
196:           
197:           void EUSART1_Transmit_ISR(void)
198:           {
199:           
200:               // add your EUSART1 interrupt custom code
201:               if(sizeof(eusart1TxBuffer) > eusart1TxBufferRemaining)
0630  3008     MOVLW 0x8
0631  0140     MOVLB 0x0
0632  0245     SUBWF eusart1TxBufferRemaining, W
0633  1803     BTFSC STATUS, 0x0
0634  2E4A     GOTO 0x64A
202:               {
203:                   TX1REG = eusart1TxBuffer[eusart1TxTail++];
0635  0846     MOVF eusart1TxTail, W
0636  3EA8     ADDLW 0xA8
0637  0086     MOVWF FSR1
0638  0187     CLRF FSR1H
0639  0801     MOVF INDF1, W
063A  0142     MOVLB 0x2
063B  009A     MOVWF TX1REG
063C  3001     MOVLW 0x1
063D  00F0     MOVWF 0x170
063E  0870     MOVF 0x170, W
063F  0140     MOVLB 0x0
0640  07C6     ADDWF eusart1TxTail, F
204:                   if(sizeof(eusart1TxBuffer) <= eusart1TxTail)
0641  3008     MOVLW 0x8
0642  0246     SUBWF eusart1TxTail, W
0643  1803     BTFSC STATUS, 0x0
205:                   {
206:                       eusart1TxTail = 0;
0644  01C6     CLRF eusart1TxTail
207:                   }
208:                   eusart1TxBufferRemaining++;
0645  3001     MOVLW 0x1
0646  00F0     MOVWF __pcstackCOMMON
0647  0870     MOVF __pcstackCOMMON, W
0648  07C5     ADDWF eusart1TxBufferRemaining, F
209:               }
0649  0008     RETURN
210:               else
211:               {
212:                   PIE3bits.TX1IE = 0;
064A  014E     MOVLB 0xE
064B  1219     BCF PIE3, 0x4
213:               }
214:           }
064C  0008     RETURN
215:           
216:           void EUSART1_Receive_ISR(void)
217:           {
218:               
219:               eusart1RxStatusBuffer[eusart1RxHead].status = 0;
057C  0140     MOVLB 0x0
057D  0844     MOVF eusart1RxHead, W
057E  3E20     ADDLW 0x20
057F  0086     MOVWF FSR1
0580  0187     CLRF FSR1H
0581  0181     CLRF INDF1
220:           
221:               if(RC1STAbits.FERR){
0582  0142     MOVLB 0x2
0583  1D1D     BTFSS RC1STA, 0x2
0584  2D90     GOTO 0x590
222:                   eusart1RxStatusBuffer[eusart1RxHead].ferr = 1;
0585  0140     MOVLB 0x0
0586  0844     MOVF eusart1RxHead, W
0587  3E20     ADDLW 0x20
0588  0086     MOVWF FSR1
0589  0187     CLRF FSR1H
058A  1481     BSF INDF1, 0x1
223:                   EUSART1_FramingErrorHandler();
058B  0835     MOVF 0x35, W
058C  008A     MOVWF PCLATH
058D  0834     MOVF EUSART1_FramingErrorHandler, W
058E  000A     CALLW
058F  3185     MOVLP 0x5
224:               }
225:           
226:               if(RC1STAbits.OERR){
0590  0142     MOVLB 0x2
0591  1C9D     BTFSS RC1STA, 0x1
0592  2D9E     GOTO 0x59E
227:                   eusart1RxStatusBuffer[eusart1RxHead].oerr = 1;
0593  0140     MOVLB 0x0
0594  0844     MOVF eusart1RxHead, W
0595  3E20     ADDLW 0x20
0596  0086     MOVWF FSR1
0597  0187     CLRF FSR1H
0598  1501     BSF INDF1, 0x2
228:                   EUSART1_OverrunErrorHandler();
0599  0833     MOVF 0x33, W
059A  008A     MOVWF PCLATH
059B  0832     MOVF EUSART1_OverrunErrorHandler, W
059C  000A     CALLW
059D  3185     MOVLP 0x5
229:               }
230:               
231:               if(eusart1RxStatusBuffer[eusart1RxHead].status){
059E  0140     MOVLB 0x0
059F  0844     MOVF eusart1RxHead, W
05A0  3E20     ADDLW 0x20
05A1  0086     MOVWF FSR1
05A2  0187     CLRF FSR1H
05A3  0801     MOVF INDF1, W
05A4  1903     BTFSC STATUS, 0x2
05A5  2DAC     GOTO 0x5AC
232:                   EUSART1_ErrorHandler();
05A6  0831     MOVF 0x31, W
05A7  008A     MOVWF PCLATH
05A8  0830     MOVF EUSART1_ErrorHandler, W
05A9  000A     CALLW
05AA  3185     MOVLP 0x5
233:               } else {
05AB  0008     RETURN
234:                   EUSART1_RxDataHandler();
05AC  3186     MOVLP 0x6
05AD  2669     CALL 0x669
235:               }
236:               
237:               // or set custom function using EUSART1_SetRxInterruptHandler()
238:           }
05AE  0008     RETURN
239:           
240:           void EUSART1_RxDataHandler(void){
241:               // use this default receive interrupt handler code
242:               eusart1RxBuffer[eusart1RxHead++] = RC1REG;
0669  0142     MOVLB 0x2
066A  0819     MOVF RC1REG, W
066B  00F0     MOVWF 0x170
066C  0140     MOVLB 0x0
066D  0844     MOVF eusart1RxHead, W
066E  3EA0     ADDLW 0xA0
066F  0086     MOVWF FSR1
0670  0187     CLRF FSR1H
0671  0870     MOVF __pcstackCOMMON, W
0672  0081     MOVWF INDF1
0673  3001     MOVLW 0x1
0674  00F0     MOVWF __pcstackCOMMON
0675  0870     MOVF __pcstackCOMMON, W
0676  07C4     ADDWF eusart1RxHead, F
243:               if(sizeof(eusart1RxBuffer) <= eusart1RxHead)
0677  3008     MOVLW 0x8
0678  0244     SUBWF eusart1RxHead, W
0679  1803     BTFSC STATUS, 0x0
244:               {
245:                   eusart1RxHead = 0;
067A  01C4     CLRF eusart1RxHead
246:               }
247:               eusart1RxCount++;
067B  3001     MOVLW 0x1
067C  00F0     MOVWF __pcstackCOMMON
067D  0870     MOVF __pcstackCOMMON, W
067E  07F6     ADDWF eusart1RxCount, F
248:           }
067F  0008     RETURN
249:           
250:           void EUSART1_DefaultFramingErrorHandler(void){}
0788  0008     RETURN
251:           
252:           void EUSART1_DefaultOverrunErrorHandler(void){
253:               // EUSART1 error - restart
254:           
255:               RC1STAbits.CREN = 0;
077B  0142     MOVLB 0x2
077C  121D     BCF RC1STA, 0x4
256:               RC1STAbits.CREN = 1;
077D  161D     BSF RC1STA, 0x4
257:           
258:           }
077E  0008     RETURN
259:           
260:           void EUSART1_DefaultErrorHandler(void){
261:               EUSART1_RxDataHandler();
0782  3186     MOVLP 0x6
0783  2669     CALL 0x669
262:           }
0784  0008     RETURN
263:           
264:           void EUSART1_SetFramingErrorHandler(void (* interruptHandler)(void)){
265:               EUSART1_FramingErrorHandler = interruptHandler;
076F  0140     MOVLB 0x0
0770  0855     MOVF readValue, W
0771  00B5     MOVWF 0x35
0772  0854     MOVF InterruptHandler, W
0773  00B4     MOVWF EUSART1_FramingErrorHandler
266:           }
0774  0008     RETURN
267:           
268:           void EUSART1_SetOverrunErrorHandler(void (* interruptHandler)(void)){
269:               EUSART1_OverrunErrorHandler = interruptHandler;
0769  0140     MOVLB 0x0
076A  0855     MOVF readValue, W
076B  00B3     MOVWF 0x33
076C  0854     MOVF InterruptHandler, W
076D  00B2     MOVWF EUSART1_OverrunErrorHandler
270:           }
076E  0008     RETURN
271:           
272:           void EUSART1_SetErrorHandler(void (* interruptHandler)(void)){
273:               EUSART1_ErrorHandler = interruptHandler;
0775  0140     MOVLB 0x0
0776  0855     MOVF readValue, W
0777  00B1     MOVWF 0x31
0778  0854     MOVF InterruptHandler, W
0779  00B0     MOVWF EUSART1_ErrorHandler
274:           }
077A  0008     RETURN
275:           
276:           void EUSART1_SetTxInterruptHandler(void (* interruptHandler)(void)){
277:               EUSART1_TxDefaultInterruptHandler = interruptHandler;
075D  0140     MOVLB 0x0
075E  0855     MOVF readValue, W
075F  00B9     MOVWF 0x39
0760  0854     MOVF InterruptHandler, W
0761  00B8     MOVWF EUSART1_TxDefaultInterruptHandler
278:           }
0762  0008     RETURN
279:           
280:           void EUSART1_SetRxInterruptHandler(void (* interruptHandler)(void)){
281:               EUSART1_RxDefaultInterruptHandler = interruptHandler;
0763  0140     MOVLB 0x0
0764  0855     MOVF readValue, W
0765  00B7     MOVWF 0x37
0766  0854     MOVF InterruptHandler, W
0767  00B6     MOVWF EUSART1_RxDefaultInterruptHandler
282:           }
0768  0008     RETURN
283:           /**
284:             End of File
285:           */
---  D:/Geeky/ClockClock/ClockClock2.X/mcc_generated_files/clc1.c  --------------------------------------
1:              /**
2:                CLC1 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  clc1.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the CLC1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for CLC1.
15:                 Generation Information :
16:                     Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                     Device            :  PIC16F15355
18:                     Driver Version    :  2.11
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 2.05 and above or later
21:                     MPLAB             :  MPLAB X 5.20
22:             */ 
23:            
24:             /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:             /**
48:               Section: Included Files
49:             */
50:            
51:            #include <xc.h>
52:            #include "clc1.h"
53:            
54:            /**
55:              Section: CLC1 APIs
56:            */
57:            
58:            void CLC1_Initialize(void)
59:            {
60:                // Set the CLC1 to the options selected in the User Interface
61:            
62:                // LC1G1POL not_inverted; LC1G2POL inverted; LC1G3POL inverted; LC1G4POL inverted; LC1POL not_inverted; 
63:                CLC1POL = 0x0E;
06EC  300E     MOVLW 0xE
06ED  017C     MOVLB 0x3C
06EE  0091     MOVWF CLC1POL
64:                // LC1D1S CLCIN0 (CLCIN0PPS); 
65:                CLC1SEL0 = 0x00;
06EF  0192     CLRF CLC1SEL0
66:                // LC1D2S CLCIN0 (CLCIN0PPS); 
67:                CLC1SEL1 = 0x00;
06F0  0193     CLRF CLC1SEL1
68:                // LC1D3S CLCIN0 (CLCIN0PPS); 
69:                CLC1SEL2 = 0x00;
06F1  0194     CLRF CLC1SEL2
70:                // LC1D4S CLCIN0 (CLCIN0PPS); 
71:                CLC1SEL3 = 0x00;
06F2  0195     CLRF CLC1SEL3
72:                // LC1G1D3N disabled; LC1G1D2N disabled; LC1G1D4N disabled; LC1G1D1T enabled; LC1G1D3T disabled; LC1G1D2T disabled; LC1G1D4T disabled; LC1G1D1N disabled; 
73:                CLC1GLS0 = 0x02;
06F3  3002     MOVLW 0x2
06F4  0096     MOVWF CLC1GLS0
74:                // LC1G2D2N disabled; LC1G2D1N disabled; LC1G2D4N disabled; LC1G2D3N disabled; LC1G2D2T disabled; LC1G2D1T disabled; LC1G2D4T disabled; LC1G2D3T disabled; 
75:                CLC1GLS1 = 0x00;
06F5  0197     CLRF CLC1GLS1
76:                // LC1G3D1N disabled; LC1G3D2N disabled; LC1G3D3N disabled; LC1G3D4N disabled; LC1G3D1T disabled; LC1G3D2T disabled; LC1G3D3T disabled; LC1G3D4T disabled; 
77:                CLC1GLS2 = 0x00;
06F6  0198     CLRF CLC1GLS2
78:                // LC1G4D1N disabled; LC1G4D2N disabled; LC1G4D3N disabled; LC1G4D4N disabled; LC1G4D1T disabled; LC1G4D2T disabled; LC1G4D3T disabled; LC1G4D4T disabled; 
79:                CLC1GLS3 = 0x00;
06F7  0199     CLRF CLC1GLS3
80:                // LC1EN enabled; INTN disabled; INTP disabled; MODE 4-input AND; 
81:                CLC1CON = 0x82;
06F8  3082     MOVLW 0x82
06F9  0090     MOVWF CLC1CON
82:            
83:            }
06FA  0008     RETURN
84:            
85:            
86:            bool CLC1_OutputStatusGet(void)
87:            {
88:                return(CLC1CONbits.LC1OUT);
89:            }
90:            /**
91:             End of File
92:            */
---  D:/Geeky/ClockClock/ClockClock2.X/main.c  ----------------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F15355
18:                    Driver Version    :  2.00
19:            */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:            */
43:            
44:            #include "mcc_generated_files/mcc.h"
45:            
46:            
47:            
48:            /* =================================================================== */
49:            /* =================================================================== */
50:            /* Type Declarations                                                   */
51:            /* =================================================================== */
52:            /* =================================================================== */
53:            
54:            #define COMMAND_QUEUE_SIZE 8
55:            
56:            typedef enum
57:            {
58:                IDLE,       // No characters received
59:                COMMAND,    // Received a valid address, waiting for the command
60:                PARAM1,     // Received the command, waiting for optional parameter 1
61:                PARAM2,     // Received parameter 1, waiting for optional parameter 2
62:                SKIP        // Ignore the rest of this line
63:            } rs232State_t;
64:            
65:            
66:            // RS232 input are in the following format:
67:            //
68:            // <address><command>[<param1>[,<param2>]]<cr>
69:            //
70:            // 1. Address selects the board and motor, and is a character between 'A' and 'X',
71:            //    or '*' to select all
72:            //
73:            // 2. Command is one of the following:
74:            //      A = Goto absolute position 0 - 180, i.e.  *A0,0
75:            //      R = Goto relative position -180 to +180, i.e. AR45,-45
76:            //      S = Speed 0-99 (0=slow, 99=fast), i.e. *S50
77:            //      W = Wait for the timer in 100ms Steps, i.e e AW100 = Wait 10 seconds
78:            //      Z = Zero timer, i.e. *Z
79:            //      L = LED 0=Off,1=On,2=Flash
80:            //      P = Power Down, i.e. turn off current to the motors until the next command
81:            //      H = Halt immediately
82:            // 
83:            // 3. Param1 is optional, -32768 to +32767 and defaults to zero
84:            // 
85:            // 4. Param2 is optional, -32768 to +32767 and defaults to zero
86:            
87:            
88:            typedef struct 
89:            {
90:                char    cmd;
91:                int16_t param1;
92:                int16_t param2;
93:            } command_t;
94:            
95:            /* =================================================================== */
96:            /* =================================================================== */
97:            /* Global Variables                                                   */
98:            /* =================================================================== */
99:            /* =================================================================== */
100:           const int16_t _sines[] = {
101:                 0,  // step 0
102:                78,  // step 1  
103:               153,  // step 2
104:               222,  // step 3
105:               283,  // step 4
106:               333,  // step 5
107:               370,  // step 6
108:               392,  // step 7
109:               400,  // step 8
110:               392,  // step 9
111:               370,  // step 10
112:               333,  // step 11
113:               283,  // step 12
114:               222,  // step 13
115:               153,  // step 14
116:                78,  // step 15
117:                 0,  // step 16
118:               -78,  // step 17
119:              -153,  // step 18
120:              -222,  // step 19
121:              -283,  // step 20
122:              -333,  // step 21
123:              -370,  // step 22
124:              -392,  // step 23
125:              -400,  // step 24
126:              -392,  // step 25
127:              -370,  // step 26
128:              -333,  // step 27
129:              -283,  // step 28
130:              -222,  // step 29
131:              -153,  // step 30
132:              -78   // step 31
133:           };  
134:           
135:           
136:           const int16_t _cosines[] = {
137:               400,   // step 0
138:               392,   // step 1
139:               370,   // step 2
140:               333,   // step 3
141:               283,   // step 4
142:               222,   // step 5
143:               153,   // step 6
144:                78,   // step 7
145:                 0,   // step 8
146:               -78,   // step 9
147:              -153,   // step 10
148:              -222,   // step 11
149:              -283,   // step 12
150:              -333,   // step 13
151:              -370,   // step 14
152:              -392,   // step 15
153:              -400,   // step 16
154:              -392,   // step 17
155:              -370,   // step 18
156:              -333,   // step 19
157:              -283,   // step 20
158:              -222,   // step 21
159:              -153,   // step 22
160:               -78,   // step 23
161:                 0,   // step 24
162:                78,   // step 25
163:               153,   // step 26
164:               222,   // step 27
165:               283,   // step 28
166:               333,   // step 29
167:               370,   // step 30
168:               392    // step 31
169:           };
170:           
171:           
172:           /* Used by microstepping interrupt */
173:           int16_t _stepcount1 = 0;     // 0 = stopped, >0 = clockwise, <0 = anticlockwise
174:           int16_t _stepcount2 = 0;     // 0 = stopped, >0 = clockwise, <0 = anticlockwise
175:           uint8_t _microstep1 = 0;     // 0 - 31
176:           uint8_t _microstep2 = 0;     // 0 - 31
177:           uint8_t _position1 = 90;
178:           uint8_t _position2 = 90;
179:           
180:           // The processor's address, from 'A' for digit 1 motor 1, to 'X' for digit 4 motor 6
181:           char _myAddress;     
182:           
183:           // State machine for serial input
184:           rs232State_t _rs232State = IDLE;
185:           
186:           // temporary copy of command data, used by the state machine
187:           char _cmd = '\0';
188:           int16_t _param1 = 0;
189:           int16_t _param2 = 0;
190:           bool _param1Negative = false;
191:           bool _param2Negative = false;
192:           
193:           command_t _commandQueue[COMMAND_QUEUE_SIZE];
194:           
195:           
196:           /* =================================================================== */
197:           /* =================================================================== */
198:           /* Interrupt Handler                                                   */
199:           /* =================================================================== */
200:           /* =================================================================== */
201:           
202:           
203:           
204:           
205:           
206:           void Timer0_int_handler(void)
207:           {
208:               IO_LED_SetHigh();
01B9  0140     MOVLB 0x0
01BA  1698     BSF LATA, 0x5
209:               
210:               int16_t sin;
211:               int16_t cos;
212:           
213:               //-------------------
214:               // HOURS FINGER
215:               //-------------------
216:               if (_stepcount1 == 0)        
01BB  082E     MOVF _stepcount1, W
01BC  042F     IORWF 0x2F, W
01BD  1903     BTFSC STATUS, 0x2
01BE  2A57     GOTO 0x257
217:               {
218:                   // Nothing to do
219:               }
220:               else
221:               {
222:                   if (_stepcount1 > 0)
01BF  082F     MOVF 0x2F, W
01C0  3A80     XORLW 0x80
01C1  00F4     MOVWF 0x74
01C2  3080     MOVLW 0x80
01C3  0274     SUBWF 0x74, W
01C4  1D03     BTFSS STATUS, 0x2
01C5  29C8     GOTO 0x1C8
01C6  3001     MOVLW 0x1
01C7  022E     SUBWF _stepcount1, W
01C8  1C03     BTFSS STATUS, 0x0
01C9  29E9     GOTO 0x1E9
223:                   {        
224:                       // Move clockwise
225:                       if (_microstep1 >= 31)
01CA  301F     MOVLW 0x1F
01CB  0140     MOVLB 0x0
01CC  0242     SUBWF _microstep1, W
01CD  1C03     BTFSS STATUS, 0x0
01CE  29E4     GOTO 0x1E4
226:                       {
227:                           _microstep1 = 0;
01CF  01C2     CLRF _microstep1
228:                           _stepcount1--;                    
01D0  30FF     MOVLW 0xFF
01D1  07AE     ADDWF _stepcount1, F
01D2  30FF     MOVLW 0xFF
01D3  3DAF     ADDWFC 0x2F, F
229:                           _position1 = (_position1 == 179) ? 0 : _position1 + 1;
01D4  30B3     MOVLW 0xB3
01D5  0661     XORWF _position1, W
01D6  1903     BTFSC STATUS, 0x2
01D7  29E0     GOTO 0x1E0
01D8  0861     MOVF _position1, W
01D9  3E01     ADDLW 0x1
01DA  00C8     MOVWF __pcstackBANK0
01DB  3000     MOVLW 0x0
01DC  1803     BTFSC STATUS, 0x0
01DD  3001     MOVLW 0x1
01DE  00C9     MOVWF 0x49
01DF  29E2     GOTO 0x1E2
01E0  01C8     CLRF __pcstackBANK0
01E1  01C9     CLRF 0x49
01E2  0848     MOVF __pcstackBANK0, W
01E3  2A05     GOTO 0x205
230:                       }
231:                       else    
232:                       {
233:                           _microstep1++;
01E4  3001     MOVLW 0x1
01E5  00F4     MOVWF 0x74
01E6  0874     MOVF 0x74, W
01E7  07C2     ADDWF _microstep1, F
01E8  2A0B     GOTO 0x20B
234:                       }
235:                   }
236:                   else
237:                   {
238:                       // move anticlockwise
239:                       if (_microstep1 == 0)
01E9  0140     MOVLB 0x0
01EA  0842     MOVF _microstep1, W
01EB  1D03     BTFSS STATUS, 0x2
01EC  2A09     GOTO 0x209
240:                       {
241:                           _microstep1 = 31;
01ED  301F     MOVLW 0x1F
01EE  00F4     MOVWF 0x74
01EF  0874     MOVF 0x74, W
01F0  00C2     MOVWF _microstep1
242:                           _stepcount1++;                    
01F1  3001     MOVLW 0x1
01F2  07AE     ADDWF _stepcount1, F
01F3  3000     MOVLW 0x0
01F4  3DAF     ADDWFC 0x2F, F
243:                           _position1 = (_position1 == 0) ? 179 : _position1 - 1;
01F5  0861     MOVF _position1, W
01F6  1903     BTFSC STATUS, 0x2
01F7  2A00     GOTO 0x200
01F8  0861     MOVF _position1, W
01F9  3EFF     ADDLW 0xFF
01FA  00CA     MOVWF 0x4A
01FB  30FF     MOVLW 0xFF
01FC  1803     BTFSC STATUS, 0x0
01FD  3000     MOVLW 0x0
01FE  00CB     MOVWF 0x4B
01FF  2A04     GOTO 0x204
0200  30B3     MOVLW 0xB3
0201  00CA     MOVWF 0x4A
0202  3000     MOVLW 0x0
0203  00CB     MOVWF 0x4B
0204  084A     MOVF 0x4A, W
0205  00F4     MOVWF 0x74
0206  0874     MOVF 0x74, W
0207  00E1     MOVWF _position1
244:                       }
0208  2A0B     GOTO 0x20B
245:                       else
246:                       {
247:                           _microstep1--;
0209  3001     MOVLW 0x1
020A  02C2     SUBWF _microstep1, F
248:                       }    
249:                   }
250:           
251:                   sin = _sines[_microstep1];        
020B  0842     MOVF _microstep1, W
020C  00F4     MOVWF 0x74
020D  01F5     CLRF 0x75
020E  35F4     LSLF 0x74, F
020F  0DF5     RLF 0x75, F
0210  3098     MOVLW 0x98
0211  0774     ADDWF 0x74, W
0212  0084     MOVWF FSR0
0213  3084     MOVLW 0x84
0214  3D75     ADDWFC 0x75, W
0215  0085     MOVWF FSR0H
0216  3F00     MOVIW [0]FSR0
0217  00D0     MOVWF sin
0218  3F01     MOVIW [1]FSR0
0219  00D1     MOVWF 0x51
252:                   cos = _cosines[_microstep1];
021A  0842     MOVF _microstep1, W
021B  00F4     MOVWF 0x74
021C  01F5     CLRF 0x75
021D  35F4     LSLF 0x74, F
021E  0DF5     RLF 0x75, F
021F  3058     MOVLW 0x58
0220  0774     ADDWF 0x74, W
0221  0084     MOVWF FSR0
0222  3084     MOVLW 0x84
0223  3D75     ADDWFC 0x75, W
0224  0085     MOVWF FSR0H
0225  3F00     MOVIW [0]FSR0
0226  00D2     MOVWF cos
0227  3F01     MOVIW [1]FSR0
0228  00D3     MOVWF 0x53
253:           
254:                   if (sin >= 0)
0229  1BD1     BTFSC 0x51, 0x7
022A  2A35     GOTO 0x235
255:                   {
256:                      PWM3_LoadDutyValue(sin);
022B  0851     MOVF 0x51, W
022C  00F1     MOVWF 0x71
022D  0850     MOVF sin, W
022E  00F0     MOVWF __pcstackCOMMON
022F  3186     MOVLP 0x6
0230  26C2     CALL 0x6C2
0231  3181     MOVLP 0x1
257:                      IO_MOTOR1B_SetLow();
0232  0140     MOVLB 0x0
0233  1219     BCF LATB, 0x4
0234  2A40     GOTO 0x240
258:                   }
259:                   else
260:                   {
261:                      PWM3_LoadDutyValue(400 + sin);
0235  0850     MOVF sin, W
0236  3E90     ADDLW 0x90
0237  00F0     MOVWF __pcstackCOMMON
0238  3001     MOVLW 0x1
0239  3D51     ADDWFC 0x51, W
023A  00F1     MOVWF 0x71
023B  3186     MOVLP 0x6
023C  26C2     CALL 0x6C2
023D  3181     MOVLP 0x1
262:                      IO_MOTOR1B_SetHigh();
023E  0140     MOVLB 0x0
023F  1619     BSF LATB, 0x4
263:                   }
264:           
265:                   if (cos >= 0)
0240  1BD3     BTFSC 0x53, 0x7
0241  2A4C     GOTO 0x24C
266:                   {
267:                      PWM4_LoadDutyValue(cos);
0242  0853     MOVF 0x53, W
0243  00F1     MOVWF 0x71
0244  0852     MOVF cos, W
0245  00F0     MOVWF __pcstackCOMMON
0246  3186     MOVLP 0x6
0247  26AC     CALL 0x6AC
0248  3181     MOVLP 0x1
268:                      IO_MOTOR2B_SetLow();
0249  0140     MOVLB 0x0
024A  1119     BCF LATB, 0x2
024B  2A57     GOTO 0x257
269:                   }
270:                   else
271:                   {
272:                      PWM4_LoadDutyValue(400 + cos);
024C  0852     MOVF cos, W
024D  3E90     ADDLW 0x90
024E  00F0     MOVWF __pcstackCOMMON
024F  3001     MOVLW 0x1
0250  3D53     ADDWFC 0x53, W
0251  00F1     MOVWF 0x71
0252  3186     MOVLP 0x6
0253  26AC     CALL 0x6AC
0254  3181     MOVLP 0x1
273:                      IO_MOTOR2B_SetHigh();
0255  0140     MOVLB 0x0
0256  1519     BSF LATB, 0x2
274:                   }
275:                       
276:               }
277:           
278:               //-------------------
279:               // MINUTES FINGER
280:               //-------------------
281:               if (_stepcount2 == 0)        
0257  082C     MOVF _stepcount2, W
0258  042D     IORWF 0x2D, W
0259  1903     BTFSC STATUS, 0x2
025A  2AF2     GOTO 0x2F2
282:               {
283:                   // Nothing to do
284:               }
285:               else
286:               {
287:                   if (_stepcount2 > 0)
025B  082D     MOVF 0x2D, W
025C  3A80     XORLW 0x80
025D  00F4     MOVWF 0x74
025E  3080     MOVLW 0x80
025F  0274     SUBWF 0x74, W
0260  1D03     BTFSS STATUS, 0x2
0261  2A64     GOTO 0x264
0262  3001     MOVLW 0x1
0263  022C     SUBWF _stepcount2, W
0264  1C03     BTFSS STATUS, 0x0
0265  2A85     GOTO 0x285
288:                   {        
289:                       // Move clockwise one step
290:                       if (_microstep2 >= 31)
0266  301F     MOVLW 0x1F
0267  0140     MOVLB 0x0
0268  0241     SUBWF _microstep2, W
0269  1C03     BTFSS STATUS, 0x0
026A  2A80     GOTO 0x280
291:                       {
292:                           _microstep2 = 0;
026B  01C1     CLRF _microstep2
293:                           _stepcount2--;                    
026C  30FF     MOVLW 0xFF
026D  07AC     ADDWF _stepcount2, F
026E  30FF     MOVLW 0xFF
026F  3DAD     ADDWFC 0x2D, F
294:                           _position2 = (_position2 == 179) ? 0 : _position2 + 1;
0270  30B3     MOVLW 0xB3
0271  0660     XORWF _position2, W
0272  1903     BTFSC STATUS, 0x2
0273  2A7C     GOTO 0x27C
0274  0860     MOVF _position2, W
0275  3E01     ADDLW 0x1
0276  00CC     MOVWF 0x4C
0277  3000     MOVLW 0x0
0278  1803     BTFSC STATUS, 0x0
0279  3001     MOVLW 0x1
027A  00CD     MOVWF 0x4D
027B  2A7E     GOTO 0x27E
027C  01CC     CLRF 0x4C
027D  01CD     CLRF 0x4D
027E  084C     MOVF 0x4C, W
027F  2AA1     GOTO 0x2A1
295:                       }
296:                       else    
297:                       {
298:                           _microstep2++;
0280  3001     MOVLW 0x1
0281  00F4     MOVWF 0x74
0282  0874     MOVF 0x74, W
0283  07C1     ADDWF _microstep2, F
0284  2AA7     GOTO 0x2A7
299:                       }
300:                   }
301:                   else
302:                   {
303:                       if (_microstep2 == 0)
0285  0140     MOVLB 0x0
0286  0841     MOVF _microstep2, W
0287  1D03     BTFSS STATUS, 0x2
0288  2AA5     GOTO 0x2A5
304:                       {
305:                           _microstep2 = 31;
0289  301F     MOVLW 0x1F
028A  00F4     MOVWF 0x74
028B  0874     MOVF 0x74, W
028C  00C1     MOVWF _microstep2
306:                           _stepcount2++;
028D  3001     MOVLW 0x1
028E  07AC     ADDWF _stepcount2, F
028F  3000     MOVLW 0x0
0290  3DAD     ADDWFC 0x2D, F
307:                           _position2 = (_position2 == 0) ? 179 : _position2 - 1;
0291  0860     MOVF _position2, W
0292  1903     BTFSC STATUS, 0x2
0293  2A9C     GOTO 0x29C
0294  0860     MOVF _position2, W
0295  3EFF     ADDLW 0xFF
0296  00CE     MOVWF 0x4E
0297  30FF     MOVLW 0xFF
0298  1803     BTFSC STATUS, 0x0
0299  3000     MOVLW 0x0
029A  00CF     MOVWF 0x4F
029B  2AA0     GOTO 0x2A0
029C  30B3     MOVLW 0xB3
029D  00CE     MOVWF 0x4E
029E  3000     MOVLW 0x0
029F  00CF     MOVWF 0x4F
02A0  084E     MOVF 0x4E, W
02A1  00F4     MOVWF 0x74
02A2  0874     MOVF 0x74, W
02A3  00E0     MOVWF _position2
308:                       }
02A4  2AA7     GOTO 0x2A7
309:                       else
310:                       {
311:                           _microstep2--;
02A5  3001     MOVLW 0x1
02A6  02C1     SUBWF _microstep2, F
312:                       }    
313:                   }
314:           
315:                   sin = _sines[_microstep2];        
02A7  0841     MOVF _microstep2, W
02A8  00F4     MOVWF 0x74
02A9  01F5     CLRF 0x75
02AA  35F4     LSLF 0x74, F
02AB  0DF5     RLF 0x75, F
02AC  3098     MOVLW 0x98
02AD  0774     ADDWF 0x74, W
02AE  0084     MOVWF FSR0
02AF  3084     MOVLW 0x84
02B0  3D75     ADDWFC 0x75, W
02B1  0085     MOVWF FSR0H
02B2  3F00     MOVIW [0]FSR0
02B3  00D0     MOVWF sin
02B4  3F01     MOVIW [1]FSR0
02B5  00D1     MOVWF 0x51
316:                   cos = _cosines[_microstep2];
02B6  0841     MOVF _microstep2, W
02B7  00F4     MOVWF 0x74
02B8  01F5     CLRF 0x75
02B9  35F4     LSLF 0x74, F
02BA  0DF5     RLF 0x75, F
02BB  3058     MOVLW 0x58
02BC  0774     ADDWF 0x74, W
02BD  0084     MOVWF FSR0
02BE  3084     MOVLW 0x84
02BF  3D75     ADDWFC 0x75, W
02C0  0085     MOVWF FSR0H
02C1  3F00     MOVIW [0]FSR0
02C2  00D2     MOVWF cos
02C3  3F01     MOVIW [1]FSR0
02C4  00D3     MOVWF 0x53
317:           
318:                   if (sin >= 0)
02C5  1BD1     BTFSC 0x51, 0x7
02C6  2AD1     GOTO 0x2D1
319:                   {
320:                      PWM5_LoadDutyValue(sin);
02C7  0851     MOVF 0x51, W
02C8  00F1     MOVWF 0x71
02C9  0850     MOVF sin, W
02CA  00F0     MOVWF __pcstackCOMMON
02CB  3186     MOVLP 0x6
02CC  2696     CALL 0x696
02CD  3181     MOVLP 0x1
321:                      IO_MOTOR3B_SetLow();
02CE  0140     MOVLB 0x0
02CF  131A     BCF LATC, 0x6
02D0  2ADC     GOTO 0x2DC
322:                   }
323:                   else
324:                   {
325:                      PWM5_LoadDutyValue(400 + sin);
02D1  0850     MOVF sin, W
02D2  3E90     ADDLW 0x90
02D3  00F0     MOVWF __pcstackCOMMON
02D4  3001     MOVLW 0x1
02D5  3D51     ADDWFC 0x51, W
02D6  00F1     MOVWF 0x71
02D7  3186     MOVLP 0x6
02D8  2696     CALL 0x696
02D9  3181     MOVLP 0x1
326:                      IO_MOTOR3B_SetHigh();
02DA  0140     MOVLB 0x0
02DB  171A     BSF LATC, 0x6
327:                   }
328:           
329:                   if (cos >= 0)
02DC  1BD3     BTFSC 0x53, 0x7
02DD  2AE8     GOTO 0x2E8
330:                   {
331:                      PWM6_LoadDutyValue(cos);
02DE  0853     MOVF 0x53, W
02DF  00F1     MOVWF 0x71
02E0  0852     MOVF cos, W
02E1  00F0     MOVWF __pcstackCOMMON
02E2  3186     MOVLP 0x6
02E3  2680     CALL 0x680
02E4  3181     MOVLP 0x1
332:                      IO_MOTOR4B_SetLow();
02E5  0140     MOVLB 0x0
02E6  121A     BCF LATC, 0x4
02E7  2AF2     GOTO 0x2F2
333:                   }
334:                   else
335:                   {
336:                      PWM6_LoadDutyValue(400 + cos);
02E8  0852     MOVF cos, W
02E9  3E90     ADDLW 0x90
02EA  00F0     MOVWF __pcstackCOMMON
02EB  3001     MOVLW 0x1
02EC  3D53     ADDWFC 0x53, W
02ED  00F1     MOVWF 0x71
02EE  3186     MOVLP 0x6
02EF  2680     CALL 0x680
337:                      IO_MOTOR4B_SetHigh();
02F0  0140     MOVLB 0x0
02F1  161A     BSF LATC, 0x4
338:                   }
339:               }
340:           
341:               IO_LED_SetLow();
02F2  1298     BCF LATA, 0x5
342:           }
02F3  0008     RETURN
343:           
344:           
345:           /* =================================================================== */
346:           /* =================================================================== */
347:           
348:           
349:           /* Wait until both motors have stopped moving */
350:           void wait()
351:           {
352:               int16_t sc1;
353:               int16_t sc2;
354:               
355:               do
356:               {
357:                   __delay_ms(10);
0613  3068     MOVLW 0x68
0614  0140     MOVLB 0x0
0615  00D4     MOVWF InterruptHandler
0616  30E4     MOVLW 0xE4
0617  0B89     DECFSZ WREG, F
0618  2E17     GOTO 0x617
0619  0BD4     DECFSZ InterruptHandler, F
061A  2E17     GOTO 0x617
061B  0000     NOP
358:                   INTERRUPT_GlobalInterruptDisable();   
061C  138B     BCF INTCON, 0x7
359:                   sc1 = _stepcount1;
061D  0140     MOVLB 0x0
061E  082F     MOVF 0x2F, W
061F  00D6     MOVWF multiplicand
0620  082E     MOVF _stepcount1, W
0621  00D5     MOVWF readValue
360:                   sc2 = _stepcount2;
0622  082D     MOVF 0x2D, W
0623  00D8     MOVWF product
0624  082C     MOVF _stepcount2, W
0625  00D7     MOVWF sc2
361:                   INTERRUPT_GlobalInterruptEnable();           
0626  178B     BSF INTCON, 0x7
362:               } while ((sc1!=0) || (sc2!=0));
0627  0855     MOVF readValue, W
0628  0456     IORWF multiplicand, W
0629  1D03     BTFSS STATUS, 0x2
062A  2E13     GOTO 0x613
062B  0857     MOVF sc2, W
062C  0458     IORWF product, W
062D  1903     BTFSC STATUS, 0x2
062E  0008     RETURN
062F  2E13     GOTO 0x613
363:               
364:           }
365:           
366:           
367:           void moveRelative1(int16_t steps)
368:           {    
369:               INTERRUPT_GlobalInterruptDisable();
0722  138B     BCF INTCON, 0x7
370:               _stepcount1 = steps;
0723  0140     MOVLB 0x0
0724  0855     MOVF readValue, W
0725  00AF     MOVWF 0x2F
0726  0854     MOVF InterruptHandler, W
0727  00AE     MOVWF _stepcount1
371:               INTERRUPT_GlobalInterruptEnable();
0728  178B     BSF INTCON, 0x7
372:           }
0729  0008     RETURN
373:           
374:           
375:           void moveRelative2(int16_t steps)
376:           {    
377:               INTERRUPT_GlobalInterruptDisable();
378:               _stepcount2 = steps;
379:               INTERRUPT_GlobalInterruptEnable();
380:           }
381:           
382:           
383:           /* Move motor 1 to absolute position (0 - 180) */
384:           void seek1(uint16_t pos1)
385:           {
386:               int16_t offset1 = pos1 - _position1;
050F  0140     MOVLB 0x0
0510  0861     MOVF _position1, W
0511  00D6     MOVWF multiplicand
0512  01D7     CLRF sc2
0513  0856     MOVF multiplicand, W
0514  0254     SUBWF InterruptHandler, W
0515  00D8     MOVWF product
0516  0857     MOVF sc2, W
0517  3B55     SUBWFB readValue, W
0518  00D9     MOVWF 0x59
387:               
388:               if (offset1 >= 90)
0519  0859     MOVF 0x59, W
051A  3A80     XORLW 0x80
051B  00D6     MOVWF multiplicand
051C  3080     MOVLW 0x80
051D  0256     SUBWF multiplicand, W
051E  1D03     BTFSS STATUS, 0x2
051F  2D22     GOTO 0x522
0520  305A     MOVLW 0x5A
0521  0258     SUBWF product, W
0522  1C03     BTFSS STATUS, 0x0
0523  2D29     GOTO 0x529
389:                   offset1 -= 180;
0524  304C     MOVLW 0x4C
0525  0140     MOVLB 0x0
0526  07D8     ADDWF product, F
0527  30FF     MOVLW 0xFF
0528  2D39     GOTO 0x539
390:               else if (offset1 <= -90)
0529  0140     MOVLB 0x0
052A  0859     MOVF 0x59, W
052B  3A80     XORLW 0x80
052C  00D6     MOVWF multiplicand
052D  307F     MOVLW 0x7F
052E  0256     SUBWF multiplicand, W
052F  1D03     BTFSS STATUS, 0x2
0530  2D33     GOTO 0x533
0531  30A7     MOVLW 0xA7
0532  0258     SUBWF product, W
0533  1803     BTFSC STATUS, 0x0
0534  2D3A     GOTO 0x53A
391:                   offset1 += 180;
0535  30B4     MOVLW 0xB4
0536  0140     MOVLB 0x0
0537  07D8     ADDWF product, F
0538  3000     MOVLW 0x0
0539  3DD9     ADDWFC 0x59, F
392:               
393:               if (offset1 != 0) 
053A  0140     MOVLB 0x0
053B  0858     MOVF product, W
053C  0459     IORWF 0x59, W
053D  1903     BTFSC STATUS, 0x2
053E  0008     RETURN
394:               {
395:                   INTERRUPT_GlobalInterruptDisable();   
053F  138B     BCF INTCON, 0x7
396:                   _stepcount1 = offset1;
0540  0859     MOVF 0x59, W
0541  00AF     MOVWF 0x2F
0542  0858     MOVF product, W
0543  00AE     MOVWF _stepcount1
397:                   INTERRUPT_GlobalInterruptEnable();
0544  178B     BSF INTCON, 0x7
398:               }       
399:           }
0545  0008     RETURN
400:           
401:           
402:           /* Move motor 2 to absolute position (0 - 180) */
403:           void seek2(uint16_t pos2)
404:           {
405:               int16_t offset2 = pos2 - _position2;
04D8  0140     MOVLB 0x0
04D9  0860     MOVF _position2, W
04DA  00D6     MOVWF multiplicand
04DB  01D7     CLRF sc2
04DC  0856     MOVF multiplicand, W
04DD  0254     SUBWF InterruptHandler, W
04DE  00D8     MOVWF product
04DF  0857     MOVF sc2, W
04E0  3B55     SUBWFB readValue, W
04E1  00D9     MOVWF 0x59
406:               
407:               if (offset2 >= 90)
04E2  0859     MOVF 0x59, W
04E3  3A80     XORLW 0x80
04E4  00D6     MOVWF multiplicand
04E5  3080     MOVLW 0x80
04E6  0256     SUBWF multiplicand, W
04E7  1D03     BTFSS STATUS, 0x2
04E8  2CEB     GOTO 0x4EB
04E9  305A     MOVLW 0x5A
04EA  0258     SUBWF product, W
04EB  1C03     BTFSS STATUS, 0x0
04EC  2CF2     GOTO 0x4F2
408:                   offset2 -= 180;
04ED  304C     MOVLW 0x4C
04EE  0140     MOVLB 0x0
04EF  07D8     ADDWF product, F
04F0  30FF     MOVLW 0xFF
04F1  2D02     GOTO 0x502
409:               else if (offset2 <= -90)
04F2  0140     MOVLB 0x0
04F3  0859     MOVF 0x59, W
04F4  3A80     XORLW 0x80
04F5  00D6     MOVWF multiplicand
04F6  307F     MOVLW 0x7F
04F7  0256     SUBWF multiplicand, W
04F8  1D03     BTFSS STATUS, 0x2
04F9  2CFC     GOTO 0x4FC
04FA  30A7     MOVLW 0xA7
04FB  0258     SUBWF product, W
04FC  1803     BTFSC STATUS, 0x0
04FD  2D03     GOTO 0x503
410:                   offset2 += 180;
04FE  30B4     MOVLW 0xB4
04FF  0140     MOVLB 0x0
0500  07D8     ADDWF product, F
0501  3000     MOVLW 0x0
0502  3DD9     ADDWFC 0x59, F
411:           
412:               if (offset2 != 0) 
0503  0140     MOVLB 0x0
0504  0858     MOVF product, W
0505  0459     IORWF 0x59, W
0506  1903     BTFSC STATUS, 0x2
0507  0008     RETURN
413:               {
414:                   INTERRUPT_GlobalInterruptDisable();   
0508  138B     BCF INTCON, 0x7
415:                   _stepcount2 = offset2;
0509  0859     MOVF 0x59, W
050A  00AD     MOVWF 0x2D
050B  0858     MOVF product, W
050C  00AC     MOVWF _stepcount2
416:                   INTERRUPT_GlobalInterruptEnable();
050D  178B     BSF INTCON, 0x7
417:               }
418:                       
419:           }
050E  0008     RETURN
420:           
421:           
422:           // Todo : Make it timer interrupt driven
423:           void flashLED()
424:           {
425:               IO_LED_SetHigh();
05F4  0140     MOVLB 0x0
05F5  1698     BSF LATA, 0x5
426:               __delay_ms(300);
05F6  300D     MOVLW 0xD
05F7  0140     MOVLB 0x0
05F8  00D5     MOVWF readValue
05F9  302D     MOVLW 0x2D
05FA  00D4     MOVWF InterruptHandler
05FB  30D7     MOVLW 0xD7
05FC  0B89     DECFSZ WREG, F
05FD  2DFC     GOTO 0x5FC
05FE  0BD4     DECFSZ InterruptHandler, F
05FF  2DFC     GOTO 0x5FC
0600  0BD5     DECFSZ readValue, F
0601  2DFC     GOTO 0x5FC
0602  3200     BRA 0x603
427:               IO_LED_SetLow();
0603  0140     MOVLB 0x0
0604  1298     BCF LATA, 0x5
428:               __delay_ms(200);  
0605  3009     MOVLW 0x9
0606  0140     MOVLB 0x0
0607  00D5     MOVWF readValue
0608  301E     MOVLW 0x1E
0609  00D4     MOVWF InterruptHandler
060A  30E4     MOVLW 0xE4
060B  0B89     DECFSZ WREG, F
060C  2E0B     GOTO 0x60B
060D  0BD4     DECFSZ InterruptHandler, F
060E  2E0B     GOTO 0x60B
060F  0BD5     DECFSZ readValue, F
0610  2E0B     GOTO 0x60B
0611  0000     NOP
429:           }
0612  0008     RETURN
430:           
431:           
432:           
433:           void read_char()
434:           {   
435:               char rxChar;
436:               eusart1_status_t rxStatus;
437:                   
438:               if (EUSART1_is_rx_ready()) 
02F4  3187     MOVLP 0x7
02F5  2732     CALL 0x732
02F6  3182     MOVLP 0x2
02F7  3A00     XORLW 0x0
02F8  1903     BTFSC STATUS, 0x2
02F9  0008     RETURN
439:               {
440:               
441:                   rxChar = (char)EUSART1_Read();
02FA  3185     MOVLP 0x5
02FB  25AF     CALL 0x5AF
02FC  3182     MOVLP 0x2
02FD  0140     MOVLB 0x0
02FE  00DA     MOVWF 0x5A
02FF  085A     MOVF 0x5A, W
0300  0141     MOVLB 0x1
0301  00DE     MOVWF rxChar
442:                   rxStatus = EUSART1_get_last_status();
0302  3187     MOVLP 0x7
0303  277F     CALL 0x77F
0304  3182     MOVLP 0x2
0305  0140     MOVLB 0x0
0306  00DA     MOVWF 0x5A
0307  085A     MOVF 0x5A, W
0308  0141     MOVLB 0x1
0309  00D8     MOVWF __pcstackBANK1
443:           
444:                   if(rxStatus.ferr) 
030A  1CD8     BTFSS __pcstackBANK1, 0x1
030B  2B14     GOTO 0x314
445:                   {
446:                       // Serial framing error. 
447:                       flashLED();
030C  3185     MOVLP 0x5
030D  25F4     CALL 0x5F4
448:                       _rs232State = SKIP;
030E  3004     MOVLW 0x4
030F  0140     MOVLB 0x0
0310  00DA     MOVWF 0x5A
0311  085A     MOVF 0x5A, W
0312  00BF     MOVWF _rs232State
449:                   }
0313  0008     RETURN
450:                   else if ((rxChar == '\r') || (rxChar == '\n')) 
0314  300D     MOVLW 0xD
0315  065E     XORWF 0x5E, W
0316  1903     BTFSC STATUS, 0x2
0317  2B1C     GOTO 0x31C
0318  300A     MOVLW 0xA
0319  065E     XORWF 0x5E, W
031A  1D03     BTFSS STATUS, 0x2
031B  2B80     GOTO 0x380
451:                   {
452:                       // End of line. Start processing the current command (if any)
453:                       if ((_rs232State == PARAM1) || (_rs232State == PARAM2)) { 
031C  3002     MOVLW 0x2
031D  0140     MOVLB 0x0
031E  063F     XORWF _rs232State, W
031F  1903     BTFSC STATUS, 0x2
0320  2B25     GOTO 0x325
0321  3003     MOVLW 0x3
0322  063F     XORWF _rs232State, W
0323  1D03     BTFSS STATUS, 0x2
0324  2B76     GOTO 0x376
454:           
455:                           // push the command and any parameters onto the command queue   
456:                           command_t* cmdPtr = &_commandQueue[0];
0325  30B0     MOVLW 0xB0
0326  00DA     MOVWF 0x5A
0327  085A     MOVF 0x5A, W
0328  0141     MOVLB 0x1
0329  00DD     MOVWF cmdPtr
457:                           cmdPtr->cmd = _cmd;
032A  0140     MOVLB 0x0
032B  083E     MOVF _cmd, W
032C  00DA     MOVWF 0x5A
032D  0141     MOVLB 0x1
032E  085D     MOVF cmdPtr, W
032F  0086     MOVWF 0x86
0330  0187     CLRF 0x87
0331  0140     MOVLB 0x0
0332  085A     MOVF 0x5A, W
0333  0081     MOVWF INDF1
458:           
459:                           cmdPtr->param1 = _param1Negative ? -_param1 : _param1;
0334  083D     MOVF _param1Negative, W
0335  1D03     BTFSS STATUS, 0x2
0336  2B3F     GOTO 0x33F
0337  082B     MOVF 0x2B, W
0338  0141     MOVLB 0x1
0339  00DA     MOVWF 0xDA
033A  0140     MOVLB 0x0
033B  082A     MOVF _param1, W
033C  0141     MOVLB 0x1
033D  00D9     MOVWF 0xD9
033E  2B4D     GOTO 0x34D
033F  092A     COMF 0xAA, W
0340  00DA     MOVWF 0xDA
0341  092B     COMF 0xAB, W
0342  00DB     MOVWF 0xDB
0343  0ADA     INCF 0xDA, F
0344  1903     BTFSC 0x83, 0x2
0345  0ADB     INCF 0xDB, F
0346  085A     MOVF 0xDA, W
0347  0141     MOVLB 0x1
0348  00D9     MOVWF 0xD9
0349  0140     MOVLB 0x0
034A  085B     MOVF 0x5B, W
034B  0141     MOVLB 0x1
034C  00DA     MOVWF 0xDA
034D  0A5D     INCF cmdPtr, W
034E  0086     MOVWF 0x86
034F  0187     CLRF 0x87
0350  0859     MOVF 0xD9, W
0351  3FC0     MOVWI [0]FSR1
0352  085A     MOVF 0xDA, W
0353  3FC1     MOVWI [1]FSR1
460:                           cmdPtr->param2 = _param2Negative ? -_param2 : _param2;
0354  0140     MOVLB 0x0
0355  083C     MOVF _param2Negative, W
0356  1D03     BTFSS STATUS, 0x2
0357  2B60     GOTO 0x360
0358  0829     MOVF 0x29, W
0359  0141     MOVLB 0x1
035A  00DC     MOVWF 0xDC
035B  0140     MOVLB 0x0
035C  0828     MOVF _param2, W
035D  0141     MOVLB 0x1
035E  00DB     MOVWF 0xDB
035F  2B6E     GOTO 0x36E
0360  0928     COMF eusart1TxBuffer, W
0361  00DA     MOVWF 0xDA
0362  0929     COMF 0xA9, W
0363  00DB     MOVWF 0xDB
0364  0ADA     INCF 0xDA, F
0365  1903     BTFSC 0x83, 0x2
0366  0ADB     INCF 0xDB, F
0367  085A     MOVF 0xDA, W
0368  0141     MOVLB 0x1
0369  00DB     MOVWF 0xDB
036A  0140     MOVLB 0x0
036B  085B     MOVF 0x5B, W
036C  0141     MOVLB 0x1
036D  00DC     MOVWF 0xDC
036E  085D     MOVF cmdPtr, W
036F  3E03     ADDLW 0x3
0370  0086     MOVWF 0x86
0371  0187     CLRF 0x87
0372  085B     MOVF 0xDB, W
0373  3FC0     MOVWI [0]FSR1
0374  085C     MOVF 0xDC, W
0375  3FC1     MOVWI [1]FSR1
461:                       }
462:           
463:                       _cmd = '\0';
0376  0140     MOVLB 0x0
0377  01BE     CLRF _cmd
464:                       _param1 = 0;
0378  01AA     CLRF _param1
0379  01AB     CLRF 0x2B
465:                       _param2 = 0;       
037A  01A8     CLRF _param2
037B  01A9     CLRF 0x29
466:                       _param1Negative = false;
037C  01BD     CLRF _param1Negative
467:                       _param2Negative = false;
037D  01BC     CLRF _param2Negative
468:                       _rs232State = IDLE;
037E  01BF     CLRF _rs232State
469:                   }
037F  0008     RETURN
470:                   else if (_rs232State == IDLE) 
0380  0140     MOVLB 0x0
0381  083F     MOVF _rs232State, W
0382  1D03     BTFSS STATUS, 0x2
0383  2B92     GOTO 0x392
471:                   {
472:                       // Check if the next command is for us
473:                       if ((rxChar == '*') || (rxChar == _myAddress)) {
0384  302A     MOVLW 0x2A
0385  0141     MOVLB 0x1
0386  065E     XORWF rxChar, W
0387  1903     BTFSC 0x83, 0x2
0388  2B8E     GOTO 0x38E
0389  085E     MOVF rxChar, W
038A  0140     MOVLB 0x0
038B  0640     XORWF _myAddress, W
038C  1D03     BTFSS STATUS, 0x2
038D  2B0E     GOTO 0x30E
474:                           // Yes it is, get ready for it
475:                           _rs232State = COMMAND;           
038E  0140     MOVLB 0x0
038F  01BF     CLRF _rs232State
0390  0ABF     INCF _rs232State, F
476:                       }
0391  0008     RETURN
477:                       else
478:                       {
479:                           _rs232State = SKIP;
480:                       }
481:                   } 
482:                   else if (_rs232State == COMMAND) 
0392  033F     DECF _rs232State, W
0393  1D03     BTFSS STATUS, 0x2
0394  2BA8     GOTO 0x3A8
483:                   {
484:                       if (rxChar == 'Z') {
0395  305A     MOVLW 0x5A
0396  0141     MOVLB 0x1
0397  065E     XORWF rxChar, W
0398  1903     BTFSC 0x83, 0x2
0399  2B0E     GOTO 0x30E
485:                           // Reset the timer immediately ??? TODO
486:                           _rs232State = SKIP;
487:                       }
488:                       else if (rxChar == 'H')
039A  3048     MOVLW 0x48
039B  065E     XORWF rxChar, W
039C  1903     BTFSC 0x83, 0x2
039D  2B0E     GOTO 0x30E
489:                       {
490:                           // Halt - reset everything immediately ??? TODO 
491:                           _rs232State = SKIP;
492:                       }
493:                       else
494:                       {
495:                           // Remember the command until the <CR> and get ready to 
496:                           // receive the first parameter (if any)
497:                           _cmd = rxChar;
039E  085E     MOVF rxChar, W
039F  0140     MOVLB 0x0
03A0  00DA     MOVWF 0x5A
03A1  085A     MOVF 0x5A, W
03A2  00BE     MOVWF _cmd
498:                           _rs232State = PARAM1;
03A3  3002     MOVLW 0x2
03A4  00DA     MOVWF 0x5A
03A5  085A     MOVF 0x5A, W
03A6  00BF     MOVWF _rs232State
03A7  0008     RETURN
499:                       }
500:                   }
501:                   else if (_rs232State == PARAM1)
03A8  3002     MOVLW 0x2
03A9  063F     XORWF _rs232State, W
03AA  1D03     BTFSS STATUS, 0x2
03AB  2BE3     GOTO 0x3E3
502:                   {
503:                       // Received part of the first parameter. 
504:                       if ((rxChar >= '0') && (rxChar <= '9')){
03AC  3030     MOVLW 0x30
03AD  0141     MOVLB 0x1
03AE  025E     SUBWF rxChar, W
03AF  1C03     BTFSS 0x83, 0x0
03B0  2BD1     GOTO 0x3D1
03B1  303A     MOVLW 0x3A
03B2  025E     SUBWF rxChar, W
03B3  1803     BTFSC 0x83, 0x0
03B4  2BD1     GOTO 0x3D1
505:                           _param1 = (_param1 * 10) + rxChar - '0';
03B5  085E     MOVF rxChar, W
03B6  0140     MOVLB 0x0
03B7  00DA     MOVWF 0x5A
03B8  01DB     CLRF 0x5B
03B9  082B     MOVF 0x2B, W
03BA  00D5     MOVWF readValue
03BB  082A     MOVF _param1, W
03BC  00D4     MOVWF InterruptHandler
03BD  300A     MOVLW 0xA
03BE  00D6     MOVWF multiplicand
03BF  3000     MOVLW 0x0
03C0  00D7     MOVWF sc2
03C1  3186     MOVLP 0x6
03C2  264D     CALL 0x64D
03C3  0140     MOVLB 0x0
03C4  085A     MOVF 0x5A, W
03C5  0754     ADDWF InterruptHandler, W
03C6  00DC     MOVWF 0x5C
03C7  085B     MOVF 0x5B, W
03C8  3D55     ADDWFC readValue, W
03C9  00DD     MOVWF 0x5D
03CA  085C     MOVF 0x5C, W
03CB  3ED0     ADDLW 0xD0
03CC  00AA     MOVWF _param1
03CD  30FF     MOVLW 0xFF
03CE  3D5D     ADDWFC 0x5D, W
03CF  00AB     MOVWF 0x2B
506:                       }
03D0  0008     RETURN
507:                       else if  (rxChar == '-') {
03D1  302D     MOVLW 0x2D
03D2  065E     XORWF 0x5E, W
03D3  1D03     BTFSS STATUS, 0x2
03D4  2BD9     GOTO 0x3D9
508:                           _param1Negative = true;
03D5  0140     MOVLB 0x0
03D6  01BD     CLRF _param1Negative
03D7  0ABD     INCF _param1Negative, F
509:                       }
03D8  0008     RETURN
510:                       else if (rxChar == ',') {
03D9  302C     MOVLW 0x2C
03DA  065E     XORWF 0x5E, W
03DB  1D03     BTFSS STATUS, 0x2
03DC  2B0C     GOTO 0x30C
511:                           // comma terminator - wait for the second parameter
512:                           _rs232State = PARAM2;
03DD  3003     MOVLW 0x3
03DE  0140     MOVLB 0x0
03DF  00DA     MOVWF 0x5A
03E0  085A     MOVF 0x5A, W
03E1  00BF     MOVWF _rs232State
513:                       }
03E2  0008     RETURN
514:                       else
515:                       {
516:                           // Unexpected character
517:                           flashLED();
518:                           _rs232State = SKIP;            
519:                       }
520:                   } 
521:                   else if (_rs232State == PARAM2)
03E3  3003     MOVLW 0x3
03E4  063F     XORWF _rs232State, W
03E5  1D03     BTFSS STATUS, 0x2
03E6  0008     RETURN
522:                   {
523:                       // Received part of the second parameter. 
524:                       if ((rxChar >= '0') && (rxChar <= '9')){
03E7  3030     MOVLW 0x30
03E8  0141     MOVLB 0x1
03E9  025E     SUBWF rxChar, W
03EA  1C03     BTFSS 0x83, 0x0
03EB  2C0C     GOTO 0x40C
03EC  303A     MOVLW 0x3A
03ED  025E     SUBWF rxChar, W
03EE  1803     BTFSC 0x83, 0x0
03EF  2C0C     GOTO 0x40C
525:                           _param2 = (_param2 * 10) + rxChar - '0';
03F0  085E     MOVF rxChar, W
03F1  0140     MOVLB 0x0
03F2  00DA     MOVWF 0x5A
03F3  01DB     CLRF 0x5B
03F4  0829     MOVF 0x29, W
03F5  00D5     MOVWF readValue
03F6  0828     MOVF _param2, W
03F7  00D4     MOVWF InterruptHandler
03F8  300A     MOVLW 0xA
03F9  00D6     MOVWF multiplicand
03FA  3000     MOVLW 0x0
03FB  00D7     MOVWF sc2
03FC  3186     MOVLP 0x6
03FD  264D     CALL 0x64D
03FE  0140     MOVLB 0x0
03FF  085A     MOVF 0x5A, W
0400  0754     ADDWF InterruptHandler, W
0401  00DC     MOVWF 0x5C
0402  085B     MOVF 0x5B, W
0403  3D55     ADDWFC readValue, W
0404  00DD     MOVWF 0x5D
0405  085C     MOVF 0x5C, W
0406  3ED0     ADDLW 0xD0
0407  00A8     MOVWF _param2
0408  30FF     MOVLW 0xFF
0409  3D5D     ADDWFC 0x5D, W
040A  00A9     MOVWF 0x29
526:                       }
040B  0008     RETURN
527:                       else if (rxChar == '-') {
040C  302D     MOVLW 0x2D
040D  065E     XORWF 0x5E, W
040E  1D03     BTFSS STATUS, 0x2
040F  2B0C     GOTO 0x30C
528:                           _param2Negative = true;
0410  0140     MOVLB 0x0
0411  01BC     CLRF _param2Negative
0412  0ABC     INCF _param2Negative, F
529:                       }
0413  0008     RETURN
530:                       else
531:                       {
532:                           // Unexpected character
533:                           flashLED();
534:                           _rs232State = SKIP;            
535:                       }
536:                   }
537:               }    
538:           }    
539:           
540:           
541:           /* =================================================================== */
542:           /* =================================================================== */
543:           /* MAIN CODE                                                           */
544:           /* =================================================================== */
545:           /* =================================================================== */
546:           void main(void)
547:           {
548:               // initialize the device
549:               SYSTEM_Initialize();
0044  3185     MOVLP 0x5
0045  25D3     CALL 0x5D3
0046  3180     MOVLP 0x0
550:           
551:               // Set up the timer0 (10mS) interrupt handler
552:               TMR0_SetInterruptHandler(&Timer0_int_handler);
0047  30B9     MOVLW 0xB9
0048  0140     MOVLB 0x0
0049  00D4     MOVWF InterruptHandler
004A  3001     MOVLW 0x1
004B  00D5     MOVWF readValue
004C  3187     MOVLP 0x7
004D  273F     CALL 0x73F
004E  3180     MOVLP 0x0
553:               
554:               // When using interrupts, you need to set the Global and Peripheral Interrupt Enable bits
555:               // Use the following macros to:
556:           
557:               // Enable the Global Interrupts
558:               INTERRUPT_GlobalInterruptEnable();
004F  178B     BSF INTCON, 0x7
559:               
560:               // Enable the Peripheral Interrupts
561:               INTERRUPT_PeripheralInterruptEnable();
0050  170B     BSF INTCON, 0x6
562:               
563:               // Read the board select and chip select input pins to determine our address
564:               // Board 0 addresses are "A" to "F",
565:               // Board 1 addresses are "G" to "L"
566:               // Board 2 addresses are "M" to "R"
567:               // Board 3 addresses are "S" to "X"    
568:               _myAddress = 'A';
0051  3041     MOVLW 0x41
0052  0140     MOVLB 0x0
0053  00DE     MOVWF 0x5E
0054  085E     MOVF 0x5E, W
0055  00C0     MOVWF _myAddress
569:               if (IO_CHIPSEL0_GetValue()) _myAddress += (char)1;
0056  1C0C     BTFSS PORTA, 0x0
0057  285C     GOTO 0x5C
0058  3001     MOVLW 0x1
0059  00DE     MOVWF 0x5E
005A  085E     MOVF 0x5E, W
005B  07C0     ADDWF _myAddress, F
570:               if (IO_CHIPSEL1_GetValue()) _myAddress += (char)2;
005C  1C8C     BTFSS PORTA, 0x1
005D  2862     GOTO 0x62
005E  3002     MOVLW 0x2
005F  00DE     MOVWF 0x5E
0060  085E     MOVF 0x5E, W
0061  07C0     ADDWF _myAddress, F
571:               if (IO_CHIPSEL2_GetValue()) _myAddress += (char)4;
0062  1D0C     BTFSS PORTA, 0x2
0063  2868     GOTO 0x68
0064  3004     MOVLW 0x4
0065  00DE     MOVWF 0x5E
0066  085E     MOVF 0x5E, W
0067  07C0     ADDWF _myAddress, F
572:               if (IO_DIGITSEL0_GetValue()) _myAddress += (char)6;
0068  1D8C     BTFSS PORTA, 0x3
0069  286E     GOTO 0x6E
006A  3006     MOVLW 0x6
006B  00DE     MOVWF 0x5E
006C  085E     MOVF 0x5E, W
006D  07C0     ADDWF _myAddress, F
573:               if (IO_DIGITSEL1_GetValue()) _myAddress += (char)12;
006E  1E0C     BTFSS PORTA, 0x4
006F  2874     GOTO 0x74
0070  300C     MOVLW 0xC
0071  00DE     MOVWF 0x5E
0072  085E     MOVF 0x5E, W
0073  07C0     ADDWF _myAddress, F
574:               
575:               
576:               // Flash the LED to show the address and to prove we've booted up
577:               for (char ch = 'A'; ch <= _myAddress; ch++)
0074  3041     MOVLW 0x41
0075  00DE     MOVWF 0x5E
0076  085E     MOVF 0x5E, W
0077  0141     MOVLB 0x1
0078  00E0     MOVWF ch
578:               {
579:                   flashLED();
007E  3185     MOVLP 0x5
007F  25F4     CALL 0x5F4
0080  3180     MOVLP 0x0
580:               }
0079  0860     MOVF ch, W
007A  0140     MOVLB 0x0
007B  0240     SUBWF _myAddress, W
007C  1C03     BTFSS STATUS, 0x0
007D  2888     GOTO 0x88
0081  3001     MOVLW 0x1
0082  0140     MOVLB 0x0
0083  00DE     MOVWF 0x5E
0084  085E     MOVF 0x5E, W
0085  0141     MOVLB 0x1
0086  07E0     ADDWF ch, F
0087  2879     GOTO 0x79
581:               
582:               // give the user time to move the fingers to the bottom (6 O'clock) position
583:               __delay_ms(2000);
0088  3052     MOVLW 0x52
0089  0140     MOVLB 0x0
008A  00DF     MOVWF 0x5F
008B  302B     MOVLW 0x2B
008C  00DE     MOVWF 0x5E
008D  3000     MOVLW 0x0
008E  0B89     DECFSZ WREG, F
008F  288E     GOTO 0x8E
0090  0BDE     DECFSZ 0x5E, F
0091  288E     GOTO 0x8E
0092  0BDF     DECFSZ 0x5F, F
0093  288E     GOTO 0x8E
0094  0000     NOP
584:           
585:               // Move both motors to their starting position (fully up)
586:               seek1(0);
0095  3000     MOVLW 0x0
0096  0140     MOVLB 0x0
0097  00D4     MOVWF InterruptHandler
0098  00D5     MOVWF readValue
0099  3185     MOVLP 0x5
009A  250F     CALL 0x50F
009B  3180     MOVLP 0x0
587:               seek2(0);
009C  3000     MOVLW 0x0
009D  0140     MOVLB 0x0
009E  00D4     MOVWF InterruptHandler
009F  00D5     MOVWF readValue
00A0  3184     MOVLP 0x4
00A1  24D8     CALL 0x4D8
00A2  3180     MOVLP 0x0
588:               wait();
00A3  3186     MOVLP 0x6
00A4  2613     CALL 0x613
00A5  3180     MOVLP 0x0
589:               
590:               // Start of main loop
591:               while(1)
592:               {        
593:                   read_char();
0173  3182     MOVLP 0x2
0174  22F4     CALL 0x2F4
0175  3180     MOVLP 0x0
594:                   
595:                   command_t* cmdPtr = &_commandQueue[0];
0176  30B0     MOVLW 0xB0
0177  0140     MOVLB 0x0
0178  00DE     MOVWF 0x5E
0179  085E     MOVF 0x5E, W
017A  0141     MOVLB 0x1
017B  00E1     MOVWF cmdPtr
596:                   char cmd = cmdPtr->cmd;
017C  0861     MOVF cmdPtr, W
017D  0086     MOVWF 0x86
017E  0187     CLRF 0x87
017F  0801     MOVF 0x81, W
0180  0140     MOVLB 0x0
0181  00DE     MOVWF 0x5E
0182  085E     MOVF 0x5E, W
0183  0141     MOVLB 0x1
0184  00DF     MOVWF cmd
597:                   int16_t param1 = cmdPtr->param1;
0185  0A61     INCF cmdPtr, W
0186  0086     MOVWF 0x86
0187  0187     CLRF 0x87
0188  3F40     MOVIW [0]FSR1
0189  00E4     MOVWF param1
018A  3F41     MOVIW [1]FSR1
018B  00E5     MOVWF 0xE5
598:                   int16_t param2 = cmdPtr->param2;
018C  0861     MOVF cmdPtr, W
018D  3E03     ADDLW 0x3
018E  0086     MOVWF 0x86
018F  0187     CLRF 0x87
0190  3F40     MOVIW [0]FSR1
0191  00E2     MOVWF param2
0192  3F41     MOVIW [1]FSR1
0193  00E3     MOVWF 0xE3
599:                   
600:                   switch (cmd)
00A6  2973     GOTO 0x173
601:                   {
602:                       case 'A': // Goto absolute position. Param1&2 = 0 - 180, i.e.  *A0,0
603:                           if (param1 < 0) param1 = 0;
00A7  0141     MOVLB 0x1
00A8  1FE5     BTFSS 0xE5, 0x7
00A9  28AC     GOTO 0xAC
00AA  01E4     CLRF param1
00AB  01E5     CLRF 0xE5
604:                           if (param1 > 180) param1 = 180;
00AC  0865     MOVF 0xE5, W
00AD  3A80     XORLW 0x80
00AE  0140     MOVLB 0x0
00AF  00DE     MOVWF 0x5E
00B0  3080     MOVLW 0x80
00B1  025E     SUBWF 0x5E, W
00B2  1D03     BTFSS STATUS, 0x2
00B3  28B7     GOTO 0xB7
00B4  30B5     MOVLW 0xB5
00B5  0141     MOVLB 0x1
00B6  0264     SUBWF param1, W
00B7  1C03     BTFSS 0x83, 0x0
00B8  28BE     GOTO 0xBE
00B9  30B4     MOVLW 0xB4
00BA  0141     MOVLB 0x1
00BB  00E4     MOVWF param1
00BC  3000     MOVLW 0x0
00BD  00E5     MOVWF 0xE5
605:                           if (param2 < 0) param2 = 0;
00BE  0141     MOVLB 0x1
00BF  1FE3     BTFSS 0xE3, 0x7
00C0  28C3     GOTO 0xC3
00C1  01E2     CLRF param2
00C2  01E3     CLRF 0xE3
606:                           if (param2 < 180) param2 = 180;
00C3  0863     MOVF 0xE3, W
00C4  3A80     XORLW 0x80
00C5  0140     MOVLB 0x0
00C6  00DE     MOVWF 0x5E
00C7  3080     MOVLW 0x80
00C8  025E     SUBWF 0x5E, W
00C9  1D03     BTFSS STATUS, 0x2
00CA  28CE     GOTO 0xCE
00CB  30B4     MOVLW 0xB4
00CC  0141     MOVLB 0x1
00CD  0262     SUBWF param2, W
00CE  1803     BTFSC 0x83, 0x0
00CF  28D5     GOTO 0xD5
00D0  30B4     MOVLW 0xB4
00D1  0141     MOVLB 0x1
00D2  00E2     MOVWF param2
00D3  3000     MOVLW 0x0
00D4  00E3     MOVWF 0xE3
607:                           
608:                           seek1(param1);
00D5  0141     MOVLB 0x1
00D6  0865     MOVF 0xE5, W
00D7  0140     MOVLB 0x0
00D8  00D5     MOVWF readValue
00D9  0141     MOVLB 0x1
00DA  0864     MOVF param1, W
00DB  0140     MOVLB 0x0
00DC  00D4     MOVWF InterruptHandler
00DD  3185     MOVLP 0x5
00DE  250F     CALL 0x50F
00DF  3180     MOVLP 0x0
609:                           seek2(param2);
00E0  0141     MOVLB 0x1
00E1  0863     MOVF 0xE3, W
00E2  0140     MOVLB 0x0
00E3  00D5     MOVWF readValue
00E4  0141     MOVLB 0x1
00E5  0862     MOVF param2, W
00E6  0140     MOVLB 0x0
00E7  00D4     MOVWF InterruptHandler
00E8  3184     MOVLP 0x4
00E9  24D8     CALL 0x4D8
00EA  3180     MOVLP 0x0
610:                           
611:                           cmdPtr->cmd = '\0';
00EB  0141     MOVLB 0x1
00EC  0861     MOVF cmdPtr, W
00ED  0086     MOVWF 0x86
00EE  0187     CLRF 0x87
00EF  0181     CLRF 0x81
612:                           break;
00F0  2973     GOTO 0x173
613:                           
614:                       case 'H': // Halt
615:                           // Should never get here, it its processed immediately by read_char()
616:                           break;
617:                           
618:                       case 'L': // L = LED. Param1 0=Off , 1=On , 2=Flash <param2> times
619:                           // ??? TODO
620:                           break;
621:           
622:                       case 'P': // Power Down, i.e. turn off current to the motors until the next command
623:                           // ??? TODO
624:                           break;
625:           
626:                       case 'R': // Relative position. Param1&2 = -180 to +180, i.e. AR45,-45
627:                           if (param1 < -180) param1 = -180;
00F1  0141     MOVLB 0x1
00F2  0865     MOVF 0xE5, W
00F3  3A80     XORLW 0x80
00F4  0140     MOVLB 0x0
00F5  00DE     MOVWF 0x5E
00F6  307F     MOVLW 0x7F
00F7  025E     SUBWF 0x5E, W
00F8  1D03     BTFSS STATUS, 0x2
00F9  28FD     GOTO 0xFD
00FA  304C     MOVLW 0x4C
00FB  0141     MOVLB 0x1
00FC  0264     SUBWF param1, W
00FD  1803     BTFSC 0x83, 0x0
00FE  2904     GOTO 0x104
00FF  304C     MOVLW 0x4C
0100  0141     MOVLB 0x1
0101  00E4     MOVWF param1
0102  30FF     MOVLW 0xFF
0103  00E5     MOVWF 0xE5
628:                           if (param1 > 180) param1 = 180;
0104  0141     MOVLB 0x1
0105  0865     MOVF 0xE5, W
0106  3A80     XORLW 0x80
0107  0140     MOVLB 0x0
0108  00DE     MOVWF 0x5E
0109  3080     MOVLW 0x80
010A  025E     SUBWF 0x5E, W
010B  1D03     BTFSS STATUS, 0x2
010C  2910     GOTO 0x110
010D  30B5     MOVLW 0xB5
010E  0141     MOVLB 0x1
010F  0264     SUBWF param1, W
0110  1C03     BTFSS 0x83, 0x0
0111  2917     GOTO 0x117
0112  30B4     MOVLW 0xB4
0113  0141     MOVLB 0x1
0114  00E4     MOVWF param1
0115  3000     MOVLW 0x0
0116  00E5     MOVWF 0xE5
629:                           if (param2 < -180) param2 = -180;
0117  0141     MOVLB 0x1
0118  0863     MOVF 0xE3, W
0119  3A80     XORLW 0x80
011A  0140     MOVLB 0x0
011B  00DE     MOVWF 0x5E
011C  307F     MOVLW 0x7F
011D  025E     SUBWF 0x5E, W
011E  1D03     BTFSS STATUS, 0x2
011F  2923     GOTO 0x123
0120  304C     MOVLW 0x4C
0121  0141     MOVLB 0x1
0122  0262     SUBWF param2, W
0123  1803     BTFSC 0x83, 0x0
0124  292A     GOTO 0x12A
0125  304C     MOVLW 0x4C
0126  0141     MOVLB 0x1
0127  00E2     MOVWF param2
0128  30FF     MOVLW 0xFF
0129  00E3     MOVWF 0xE3
630:                           if (param2 > 180) param2 = 180;
012A  0141     MOVLB 0x1
012B  0863     MOVF 0xE3, W
012C  3A80     XORLW 0x80
012D  0140     MOVLB 0x0
012E  00DE     MOVWF 0x5E
012F  3080     MOVLW 0x80
0130  025E     SUBWF 0x5E, W
0131  1D03     BTFSS STATUS, 0x2
0132  2936     GOTO 0x136
0133  30B5     MOVLW 0xB5
0134  0141     MOVLB 0x1
0135  0262     SUBWF param2, W
0136  1C03     BTFSS 0x83, 0x0
0137  293D     GOTO 0x13D
0138  30B4     MOVLW 0xB4
0139  0141     MOVLB 0x1
013A  00E2     MOVWF param2
013B  3000     MOVLW 0x0
013C  00E3     MOVWF 0xE3
631:                           
632:                           moveRelative1(param1);
013D  0141     MOVLB 0x1
013E  0865     MOVF 0xE5, W
013F  0140     MOVLB 0x0
0140  00D5     MOVWF readValue
0141  0141     MOVLB 0x1
0142  0864     MOVF param1, W
0143  0140     MOVLB 0x0
0144  00D4     MOVWF InterruptHandler
0145  3187     MOVLP 0x7
0146  2722     CALL 0x722
0147  3180     MOVLP 0x0
633:                           moveRelative1(param2);
0148  0141     MOVLB 0x1
0149  0863     MOVF 0xE3, W
014A  0140     MOVLB 0x0
014B  00D5     MOVWF readValue
014C  0141     MOVLB 0x1
014D  0862     MOVF param2, W
014E  0140     MOVLB 0x0
014F  00D4     MOVWF InterruptHandler
0150  3187     MOVLP 0x7
0151  2722     CALL 0x722
0152  3180     MOVLP 0x0
634:                           break;
0153  2973     GOTO 0x173
635:                           
636:                       case 'S': // Speed param1 = 1-9 (1=slow, 9=fast), i.e. *S5
637:                           if (param1 < 1) param1 = 1;
0154  0141     MOVLB 0x1
0155  0865     MOVF 0xE5, W
0156  3A80     XORLW 0x80
0157  0140     MOVLB 0x0
0158  00DE     MOVWF 0x5E
0159  3080     MOVLW 0x80
015A  025E     SUBWF 0x5E, W
015B  1D03     BTFSS STATUS, 0x2
015C  2960     GOTO 0x160
015D  3001     MOVLW 0x1
015E  0141     MOVLB 0x1
015F  0264     SUBWF param1, W
0160  1803     BTFSC 0x83, 0x0
0161  2967     GOTO 0x167
0162  3001     MOVLW 0x1
0163  0141     MOVLB 0x1
0164  00E4     MOVWF param1
0165  3000     MOVLW 0x0
0166  00E5     MOVWF 0xE5
638:                           if (param1 > 9) param1 = 9;
0167  0141     MOVLB 0x1
0168  0865     MOVF 0xE5, W
0169  3A80     XORLW 0x80
016A  0140     MOVLB 0x0
016B  00DE     MOVWF 0x5E
016C  3080     MOVLW 0x80
016D  025E     SUBWF 0x5E, W
016E  1D03     BTFSS STATUS, 0x2
016F  2973     GOTO 0x173
0170  300A     MOVLW 0xA
0171  0141     MOVLB 0x1
0172  0264     SUBWF param1, W
639:                           // ??? TODO 
640:                           break;
641:           
642:                       case 'W': // Wait for the timer in 100ms Steps
643:                           // i.e e AW100 = Wait 10 seconds after timer reset and completion of previous command
644:                           break;
645:           
646:                       case 'Z': // Zero timer
647:                           // Should never get here, it its processed immediately by read_char()
648:                           break;
649:                   }
0194  085F     MOVF cmd, W
0195  0140     MOVLB 0x0
0196  00DE     MOVWF 0x5E
0197  01DF     CLRF 0x5F
0198  085F     MOVF 0x5F, W
0199  3A00     XORLW 0x0
019A  1903     BTFSC STATUS, 0x2
019B  299D     GOTO 0x19D
019C  2973     GOTO 0x173
019D  085E     MOVF 0x5E, W
019E  3A41     XORLW 0x41
019F  1903     BTFSC STATUS, 0x2
01A0  28A7     GOTO 0xA7
01A1  3A09     XORLW 0x9
01A2  1903     BTFSC STATUS, 0x2
01A3  2973     GOTO 0x173
01A4  3A04     XORLW 0x4
01A5  1903     BTFSC STATUS, 0x2
01A6  2973     GOTO 0x173
01A7  3A1C     XORLW 0x1C
01A8  1903     BTFSC STATUS, 0x2
01A9  2973     GOTO 0x173
01AA  3A02     XORLW 0x2
01AB  1903     BTFSC STATUS, 0x2
01AC  28F1     GOTO 0xF1
01AD  3A01     XORLW 0x1
01AE  1903     BTFSC STATUS, 0x2
01AF  2954     GOTO 0x154
01B0  3A04     XORLW 0x4
01B1  1903     BTFSC STATUS, 0x2
01B2  2973     GOTO 0x173
01B3  3A0D     XORLW 0xD
01B4  1903     BTFSC STATUS, 0x2
01B5  2973     GOTO 0x173
01B6  2973     GOTO 0x173
01B7  3180     MOVLP 0x0
01B8  2825     GOTO 0x25
650:           
651:                   //__delay_ms(10);
652:               }
653:               
654:               /*
655:               while (1)
656:               {
657:                   seek1(120);
658:                   seek2(60);
659:                   
660:                   wait();
661:                   __delay_ms(1000);        
662:                   seek1(0);
663:                   seek2(0);
664:                   wait();
665:                   __delay_ms(2000);
666:                   
667:                   seek2(-45);
668:                   seek2(-45);
669:                   wait();
670:                   __delay_ms(1000);        
671:                   seek2(0);
672:                   wait();
673:                   __delay_ms(2000);
674:           
675:                   seek2(45);
676:                   wait();
677:                   __delay_ms(1000);        
678:                   seek1(-45);
679:                   seek2(135);
680:                   wait();
681:                   __delay_ms(2000);
682:                   
683:                   seek2(80);
684:                   wait();
685:                   __delay_ms(1000);        
686:           
687:           
688:                   seek2(100);
689:                   wait();
690:                   __delay_ms(1000);        
691:           
692:           
693:                   seek1(0);
694:                   seek2(0);
695:                   wait();
696:                   __delay_ms(4000);
697:               }
698:           */
699:           /*    
700:               while (1)
701:               {     
702:                   setMotorsAndWait(720,180,0,3);
703:                   __delay_ms(500);
704:                           
705:                   setMotorsAndWait(-180,180,0,0);
706:                   __delay_ms(500);
707:                   
708:                   setMotorsAndWait(-90,90,1,1);
709:                   __delay_ms(500);
710:           
711:                   for (int i=0; i<6; i++) {
712:                       setMotorsAndWait(-15,15,0,0);
713:                       __delay_ms(500);
714:                   }
715:           
716:                   setMotorsAndWait(90,-45,1,1);
717:                   __delay_ms(500);
718:           
719:                   setMotorsAndWait(360,360,0,0);
720:                   __delay_ms(100);
721:                   
722:                   setMotorsAndWait(-360,-360,0,0);
723:                   __delay_ms(1000);
724:                   
725:                   setMotorsAndWait(-90,-135,5,5);
726:           
727:                   __delay_ms(3000);
728:                   
729:               }
730:            */
731:           
732:           }
733:           /**
734:            End of File
735:           */
---  C:/Program Files (x86)/Microchip/xc8/v2.05/pic/sources/c99/common/Umul16.c  ------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
40:            
41:            #else
42:            
43:            	product = 0;
064D  0140     MOVLB 0x0
064E  01D8     CLRF product
064F  01D9     CLRF 0x59
44:            	do {
45:            		if(multiplier & 1)
0650  1C54     BTFSS InterruptHandler, 0x0
0651  2E56     GOTO 0x656
46:            			product += multiplicand;
0652  0856     MOVF multiplicand, W
0653  07D8     ADDWF product, F
0654  0857     MOVF sc2, W
0655  3DD9     ADDWFC 0x59, F
47:            		multiplicand <<= 1;
0656  3001     MOVLW 0x1
0657  35D6     LSLF multiplicand, F
0658  0DD7     RLF sc2, F
0659  0B89     DECFSZ WREG, F
065A  2E57     GOTO 0x657
48:            		multiplier >>= 1;
065B  3001     MOVLW 0x1
065C  36D5     LSRF readValue, F
065D  0CD4     RRF InterruptHandler, F
065E  0B89     DECFSZ WREG, F
065F  2E5C     GOTO 0x65C
49:            	} while(multiplier != 0);
0660  0854     MOVF InterruptHandler, W
0661  0455     IORWF readValue, W
0662  1D03     BTFSS STATUS, 0x2
0663  2E50     GOTO 0x650
50:            
51:            #endif
52:                    return product;
0664  0859     MOVF 0x59, W
0665  00D5     MOVWF readValue
0666  0858     MOVF product, W
0667  00D4     MOVWF InterruptHandler
53:            }
0668  0008     RETURN
